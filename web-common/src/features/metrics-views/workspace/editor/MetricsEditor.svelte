<script lang="ts">
  import type { EditorView } from "@codemirror/view";
  import YAMLEditor from "@rilldata/web-common/components/editor/YAMLEditor.svelte";
  import { setLineStatuses } from "@rilldata/web-common/components/editor/line-status";
  import type { V1ParseError } from "@rilldata/web-common/runtime-client";
  import { yamlSchema } from "codemirror-json-schema/yaml";
  import { mapParseErrorsToLines } from "../../errors";
  import MetricsEditorContainer from "./MetricsEditorContainer.svelte";
  import { createPlaceholder } from "./create-placeholder";
  import metricsSchema from "./metrics-schema.json";
  import { createUpdateMetricsCallback } from "./update-metrics";

  import { JSONSchema7 } from "json-schema";

  export let filePath: string;
  export let yaml: string;
  export let metricViewName: string;
  export let allErrors: V1ParseError[];

  let view: EditorView;
  const metricsJsonSchema = metricsSchema as JSONSchema7;

  /** create placeholder codemirror extension and set the inner svelte component
   * generated by the createPlaceholder callback.
   */
  $: placeholderElements = createPlaceholder(filePath, metricViewName);
  $: if (view) placeholderElements.component.setEditorView(view);

  /** create an updateMetrics event callback based on the queryClient
   * and metricsDefName.
   */
  $: updateMetrics = createUpdateMetricsCallback(filePath, metricViewName);

  $: lineBasedRuntimeErrors = mapParseErrorsToLines(allErrors, yaml);
  /** display the main error (the first in this array) at the bottom */
  $: mainError = lineBasedRuntimeErrors?.at(0);

  /** If the errors change, run the following transaction. */
  $: if (view) setLineStatuses(lineBasedRuntimeErrors, view);
</script>

<MetricsEditorContainer error={yaml?.length ? mainError : undefined}>
  <YAMLEditor
    key={filePath}
    bind:view
    content={yaml}
    extensions={[placeholderElements.extension, yamlSchema(metricsJsonSchema)]}
    whenFocused
    on:update={updateMetrics}
  />
</MetricsEditorContainer>
