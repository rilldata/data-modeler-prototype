/**
 * Generated by orval v6.21.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createMutation, createQuery } from "@tanstack/svelte-query";
import type {
  CreateMutationOptions,
  CreateQueryOptions,
  CreateQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
} from "@tanstack/svelte-query";
import type {
  QueryServiceColumnCardinalityParams,
  QueryServiceColumnDescriptiveStatisticsParams,
  QueryServiceColumnNullCountParams,
  QueryServiceColumnNumericHistogramParams,
  QueryServiceColumnRollupIntervalBody,
  QueryServiceColumnRugHistogramParams,
  QueryServiceColumnTimeGrainParams,
  QueryServiceColumnTimeRangeParams,
  QueryServiceColumnTimeSeriesBody,
  QueryServiceColumnTopKBody,
  QueryServiceExportBody,
  QueryServiceMetricsViewAggregationBody,
  QueryServiceMetricsViewComparisonBody,
  QueryServiceMetricsViewRowsBody,
  QueryServiceMetricsViewTimeRangeBody,
  QueryServiceMetricsViewTimeSeriesBody,
  QueryServiceMetricsViewToplistBody,
  QueryServiceMetricsViewTotalsBody,
  QueryServiceQueryBatch200,
  QueryServiceQueryBatchBody,
  QueryServiceQueryBody,
  QueryServiceTableCardinalityParams,
  QueryServiceTableColumnsParams,
  QueryServiceTableRowsParams,
  RpcStatus,
  V1ColumnCardinalityResponse,
  V1ColumnDescriptiveStatisticsResponse,
  V1ColumnNullCountResponse,
  V1ColumnNumericHistogramResponse,
  V1ColumnRollupIntervalResponse,
  V1ColumnRugHistogramResponse,
  V1ColumnTimeGrainResponse,
  V1ColumnTimeRangeResponse,
  V1ColumnTimeSeriesResponse,
  V1ColumnTopKResponse,
  V1ExportResponse,
  V1MetricsViewAggregationResponse,
  V1MetricsViewComparisonResponse,
  V1MetricsViewRowsResponse,
  V1MetricsViewTimeRangeResponse,
  V1MetricsViewTimeSeriesResponse,
  V1MetricsViewToplistResponse,
  V1MetricsViewTotalsResponse,
  V1QueryResponse,
  V1TableCardinalityResponse,
  V1TableColumnsResponse,
  V1TableRowsResponse,
} from "../index.schemas";
import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Get cardinality for a column
 */
export const queryServiceColumnCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/column-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>
  > = ({ signal }) =>
    queryServiceColumnCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnCardinality>>
>;
export type QueryServiceColumnCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get cardinality for a column
 */
export const createQueryServiceColumnCardinality = <
  TData = Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnCardinality>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary TableColumns returns column profiles
 */
export const queryServiceTableColumns = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  return httpClient<V1TableColumnsResponse>({
    url: `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    method: "POST",
    params,
  });
};

export const getQueryServiceTableColumnsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/columns-profile/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableColumnsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableColumns>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableColumnsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableColumns>>
  > = () => queryServiceTableColumns(instanceId, tableName, params);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableColumns>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceTableColumnsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableColumns>>
>;
export type QueryServiceTableColumnsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableColumns returns column profiles
 */
export const createQueryServiceTableColumns = <
  TData = Awaited<ReturnType<typeof queryServiceTableColumns>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableColumnsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableColumns>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceTableColumnsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const queryServiceColumnDescriptiveStatistics = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnDescriptiveStatisticsResponse>({
    url: `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnDescriptiveStatisticsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/descriptive-statistics/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnDescriptiveStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnDescriptiveStatisticsQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
  > = ({ signal }) =>
    queryServiceColumnDescriptiveStatistics(
      instanceId,
      tableName,
      params,
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnDescriptiveStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>
>;
export type QueryServiceColumnDescriptiveStatisticsQueryError =
  ErrorType<RpcStatus>;

/**
 * @summary Get basic stats for a numeric column like min, max, mean, stddev, etc
 */
export const createQueryServiceColumnDescriptiveStatistics = <
  TData = Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnDescriptiveStatisticsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnDescriptiveStatistics>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnDescriptiveStatisticsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const queryServiceExport = (
  instanceId: string,
  queryServiceExportBody: QueryServiceExportBody,
) => {
  return httpClient<V1ExportResponse>({
    url: `/v1/instances/${instanceId}/queries/export`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceExportBody,
  });
};

export const getQueryServiceExportMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    { instanceId: string; data: QueryServiceExportBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceExport>>,
  TError,
  { instanceId: string; data: QueryServiceExportBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceExport>>,
    { instanceId: string; data: QueryServiceExportBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceExport(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceExportMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceExport>>
>;
export type QueryServiceExportMutationBody = QueryServiceExportBody;
export type QueryServiceExportMutationError = ErrorType<RpcStatus>;

/**
 * @summary Export builds a URL to download the results of a query as a file.
 */
export const createQueryServiceExport = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceExport>>,
    TError,
    { instanceId: string; data: QueryServiceExportBody },
    TContext
  >;
}) => {
  const mutationOptions = getQueryServiceExportMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary MetricsViewAggregation is a generic API for running group-by queries against a metrics view.
 */
export const queryServiceMetricsViewAggregation = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
) => {
  return httpClient<V1MetricsViewAggregationResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewAggregationBody,
  });
};

export const getQueryServiceMetricsViewAggregationQueryKey = (
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsView}/aggregation`,
    queryServiceMetricsViewAggregationBody,
  ] as const;
};

export const getQueryServiceMetricsViewAggregationQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewAggregationQueryKey(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
  > = () =>
    queryServiceMetricsViewAggregation(
      instanceId,
      metricsView,
      queryServiceMetricsViewAggregationBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsView),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewAggregationQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>
>;
export type QueryServiceMetricsViewAggregationQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewAggregation is a generic API for running group-by queries against a metrics view.
 */
export const createQueryServiceMetricsViewAggregation = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsView: string,
  queryServiceMetricsViewAggregationBody: QueryServiceMetricsViewAggregationBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewAggregation>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewAggregationQueryOptions(
    instanceId,
    metricsView,
    queryServiceMetricsViewAggregationBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const queryServiceMetricsViewComparison = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
) => {
  return httpClient<V1MetricsViewComparisonResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewComparisonBody,
  });
};

export const getQueryServiceMetricsViewComparisonQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/compare-toplist`,
    queryServiceMetricsViewComparisonBody,
  ] as const;
};

export const getQueryServiceMetricsViewComparisonQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewComparisonQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
  > = () =>
    queryServiceMetricsViewComparison(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewComparisonBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewComparisonQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>
>;
export type QueryServiceMetricsViewComparisonQueryError = ErrorType<RpcStatus>;

export const createQueryServiceMetricsViewComparison = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewComparisonBody: QueryServiceMetricsViewComparisonBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewComparison>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewComparisonQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewComparisonBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export const queryServiceMetricsViewRows = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
) => {
  return httpClient<V1MetricsViewRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewRowsBody,
  });
};

export const getQueryServiceMetricsViewRowsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/rows`,
    queryServiceMetricsViewRowsBody,
  ] as const;
};

export const getQueryServiceMetricsViewRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewRowsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
  > = () =>
    queryServiceMetricsViewRows(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewRowsBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewRows>>
>;
export type QueryServiceMetricsViewRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewRows returns the underlying model rows matching a metrics view time range and filter(s).
 */
export const createQueryServiceMetricsViewRows = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewRowsBody: QueryServiceMetricsViewRowsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewRows>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewRowsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewRowsBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view
 */
export const queryServiceMetricsViewTimeRange = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
) => {
  return httpClient<V1MetricsViewTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeRangeBody,
  });
};

export const getQueryServiceMetricsViewTimeRangeQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/time-range-summary`,
    queryServiceMetricsViewTimeRangeBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeRangeQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
  > = () =>
    queryServiceMetricsViewTimeRange(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeRangeBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>
>;
export type QueryServiceMetricsViewTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeRange Get the time range summaries (min, max) for time column in a metrics view
 */
export const createQueryServiceMetricsViewTimeRange = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeRangeBody: QueryServiceMetricsViewTimeRangeBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeRange>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewTimeRangeQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeRangeBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTimeSeries = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
) => {
  return httpClient<V1MetricsViewTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTimeSeriesBody,
  });
};

export const getQueryServiceMetricsViewTimeSeriesQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/timeseries`,
    queryServiceMetricsViewTimeSeriesBody,
  ] as const;
};

export const getQueryServiceMetricsViewTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTimeSeriesQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
  > = () =>
    queryServiceMetricsViewTimeSeries(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTimeSeriesBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>
>;
export type QueryServiceMetricsViewTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTimeSeries returns time series for the measures in the metrics view.
It's a convenience API for querying a metrics view.
 */
export const createQueryServiceMetricsViewTimeSeries = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTimeSeriesBody: QueryServiceMetricsViewTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTimeSeries>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewTimeSeriesQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewToplist = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
) => {
  return httpClient<V1MetricsViewToplistResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewToplistBody,
  });
};

export const getQueryServiceMetricsViewToplistQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/toplist`,
    queryServiceMetricsViewToplistBody,
  ] as const;
};

export const getQueryServiceMetricsViewToplistQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewToplistQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
  > = () =>
    queryServiceMetricsViewToplist(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewToplistBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewToplistQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>
>;
export type QueryServiceMetricsViewToplistQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewToplist returns the top dimension values of a metrics view sorted by one or more measures.
It's a convenience API for querying a metrics view.
 */
export const createQueryServiceMetricsViewToplist = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewToplistBody: QueryServiceMetricsViewToplistBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewToplist>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewToplistQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewToplistBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const queryServiceMetricsViewTotals = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
) => {
  return httpClient<V1MetricsViewTotalsResponse>({
    url: `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceMetricsViewTotalsBody,
  });
};

export const getQueryServiceMetricsViewTotalsQueryKey = (
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/metrics-views/${metricsViewName}/totals`,
    queryServiceMetricsViewTotalsBody,
  ] as const;
};

export const getQueryServiceMetricsViewTotalsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceMetricsViewTotalsQueryKey(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
  > = () =>
    queryServiceMetricsViewTotals(
      instanceId,
      metricsViewName,
      queryServiceMetricsViewTotalsBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && metricsViewName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceMetricsViewTotalsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>
>;
export type QueryServiceMetricsViewTotalsQueryError = ErrorType<RpcStatus>;

/**
 * @summary MetricsViewTotals returns totals over a time period for the measures in a metrics view.
It's a convenience API for querying a metrics view.
 */
export const createQueryServiceMetricsViewTotals = <
  TData = Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  metricsViewName: string,
  queryServiceMetricsViewTotalsBody: QueryServiceMetricsViewTotalsBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceMetricsViewTotals>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceMetricsViewTotalsQueryOptions(
    instanceId,
    metricsViewName,
    queryServiceMetricsViewTotalsBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get the number of nulls in a column
 */
export const queryServiceColumnNullCount = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNullCountResponse>({
    url: `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNullCountQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/null-count/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNullCountQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNullCountQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>
  > = ({ signal }) =>
    queryServiceColumnNullCount(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnNullCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNullCount>>
>;
export type QueryServiceColumnNullCountQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the number of nulls in a column
 */
export const createQueryServiceColumnNullCount = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNullCountParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNullCount>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnNullCountQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get the histogram for values in a column
 */
export const queryServiceColumnNumericHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnNumericHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnNumericHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/numeric-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnNumericHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnNumericHistogramQueryKey(
      instanceId,
      tableName,
      params,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
  > = ({ signal }) =>
    queryServiceColumnNumericHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnNumericHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>
>;
export type QueryServiceColumnNumericHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the histogram for values in a column
 */
export const createQueryServiceColumnNumericHistogram = <
  TData = Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnNumericHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnNumericHistogram>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnNumericHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export const queryServiceColumnRollupInterval = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
) => {
  return httpClient<V1ColumnRollupIntervalResponse>({
    url: `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnRollupIntervalBody,
  });
};

export const getQueryServiceColumnRollupIntervalQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rollup-interval/tables/${tableName}`,
    queryServiceColumnRollupIntervalBody,
  ] as const;
};

export const getQueryServiceColumnRollupIntervalQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRollupIntervalQueryKey(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
  > = () =>
    queryServiceColumnRollupInterval(
      instanceId,
      tableName,
      queryServiceColumnRollupIntervalBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnRollupIntervalQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>
>;
export type QueryServiceColumnRollupIntervalQueryError = ErrorType<RpcStatus>;

/**
 * @summary ColumnRollupInterval returns the minimum time granularity (as well as the time range) for a specified timestamp column
 */
export const createQueryServiceColumnRollupInterval = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnRollupIntervalBody: QueryServiceColumnRollupIntervalBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRollupInterval>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnRollupIntervalQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnRollupIntervalBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary TableRows returns table rows
 */
export const queryServiceTableRows = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableRowsResponse>({
    url: `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableRowsQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rows/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableRowsQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableRows>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableRowsQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableRows>>
  > = ({ signal }) =>
    queryServiceTableRows(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableRows>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceTableRowsQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableRows>>
>;
export type QueryServiceTableRowsQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableRows returns table rows
 */
export const createQueryServiceTableRows = <
  TData = Awaited<ReturnType<typeof queryServiceTableRows>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableRowsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableRows>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceTableRowsQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get outliers for a numeric column
 */
export const queryServiceColumnRugHistogram = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnRugHistogramResponse>({
    url: `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnRugHistogramQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/rug-histogram/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnRugHistogramQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnRugHistogramQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
  > = ({ signal }) =>
    queryServiceColumnRugHistogram(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnRugHistogramQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>
>;
export type QueryServiceColumnRugHistogramQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get outliers for a numeric column
 */
export const createQueryServiceColumnRugHistogram = <
  TData = Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnRugHistogramParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnRugHistogram>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnRugHistogramQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const queryServiceColumnTimeGrain = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeGrainResponse>({
    url: `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeGrainQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/smallest-time-grain/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeGrainQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeGrainQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
  > = ({ signal }) =>
    queryServiceColumnTimeGrain(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnTimeGrainQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>
>;
export type QueryServiceColumnTimeGrainQueryError = ErrorType<RpcStatus>;

/**
 * @summary Estimates the smallest time grain present in the column
 */
export const createQueryServiceColumnTimeGrain = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeGrainParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeGrain>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnTimeGrainQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary TableCardinality returns row count
 */
export const queryServiceTableCardinality = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1TableCardinalityResponse>({
    url: `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceTableCardinalityQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/table-cardinality/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceTableCardinalityQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableCardinality>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceTableCardinalityQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>
  > = ({ signal }) =>
    queryServiceTableCardinality(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceTableCardinality>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceTableCardinalityQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceTableCardinality>>
>;
export type QueryServiceTableCardinalityQueryError = ErrorType<RpcStatus>;

/**
 * @summary TableCardinality returns row count
 */
export const createQueryServiceTableCardinality = <
  TData = Awaited<ReturnType<typeof queryServiceTableCardinality>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceTableCardinalityParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceTableCardinality>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceTableCardinalityQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const queryServiceColumnTimeRange = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ColumnTimeRangeResponse>({
    url: `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    method: "GET",
    params,
    signal,
  });
};

export const getQueryServiceColumnTimeRangeQueryKey = (
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
) => {
  return [
    `/v1/instances/${instanceId}/queries/time-range-summary/tables/${tableName}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getQueryServiceColumnTimeRangeQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeRangeQueryKey(instanceId, tableName, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
  > = ({ signal }) =>
    queryServiceColumnTimeRange(instanceId, tableName, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnTimeRangeQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeRange>>
>;
export type QueryServiceColumnTimeRangeQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get the time range summaries (min, max) for a column
 */
export const createQueryServiceColumnTimeRange = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  params?: QueryServiceColumnTimeRangeParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeRange>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnTimeRangeQueryOptions(
    instanceId,
    tableName,
    params,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export const queryServiceColumnTimeSeries = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
) => {
  return httpClient<V1ColumnTimeSeriesResponse>({
    url: `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTimeSeriesBody,
  });
};

export const getQueryServiceColumnTimeSeriesQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/timeseries/tables/${tableName}`,
    queryServiceColumnTimeSeriesBody,
  ] as const;
};

export const getQueryServiceColumnTimeSeriesQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTimeSeriesQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
  > = () =>
    queryServiceColumnTimeSeries(
      instanceId,
      tableName,
      queryServiceColumnTimeSeriesBody,
    );

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnTimeSeriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>
>;
export type QueryServiceColumnTimeSeriesQueryError = ErrorType<RpcStatus>;

/**
 * @summary Generate time series for the given measures (aggregation expressions) along with the sparkline timeseries
 */
export const createQueryServiceColumnTimeSeries = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTimeSeriesBody: QueryServiceColumnTimeSeriesBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTimeSeries>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnTimeSeriesQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTimeSeriesBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const queryServiceColumnTopK = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
) => {
  return httpClient<V1ColumnTopKResponse>({
    url: `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceColumnTopKBody,
  });
};

export const getQueryServiceColumnTopKQueryKey = (
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
) => {
  return [
    `/v1/instances/${instanceId}/queries/topk/tables/${tableName}`,
    queryServiceColumnTopKBody,
  ] as const;
};

export const getQueryServiceColumnTopKQueryOptions = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTopK>>,
      TError,
      TData
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getQueryServiceColumnTopKQueryKey(
      instanceId,
      tableName,
      queryServiceColumnTopKBody,
    );

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>
  > = () =>
    queryServiceColumnTopK(instanceId, tableName, queryServiceColumnTopKBody);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && tableName),
    ...queryOptions,
  } as CreateQueryOptions<
    Awaited<ReturnType<typeof queryServiceColumnTopK>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type QueryServiceColumnTopKQueryResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceColumnTopK>>
>;
export type QueryServiceColumnTopKQueryError = ErrorType<RpcStatus>;

/**
 * @summary Get TopK elements from a table for a column given an agg function
agg function and k are optional, defaults are count(*) and 50 respectively
 */
export const createQueryServiceColumnTopK = <
  TData = Awaited<ReturnType<typeof queryServiceColumnTopK>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  tableName: string,
  queryServiceColumnTopKBody: QueryServiceColumnTopKBody,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof queryServiceColumnTopK>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getQueryServiceColumnTopKQueryOptions(
    instanceId,
    tableName,
    queryServiceColumnTopKBody,
    options,
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const queryServiceQuery = (
  instanceId: string,
  queryServiceQueryBody: QueryServiceQueryBody,
) => {
  return httpClient<V1QueryResponse>({
    url: `/v1/instances/${instanceId}/query`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBody,
  });
};

export const getQueryServiceQueryMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQuery>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    { instanceId: string; data: QueryServiceQueryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQuery(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQuery>>
>;
export type QueryServiceQueryMutationBody = QueryServiceQueryBody;
export type QueryServiceQueryMutationError = ErrorType<RpcStatus>;

/**
 * @summary Query runs a SQL query against the instance's OLAP datastore.
 */
export const createQueryServiceQuery = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQuery>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBody },
    TContext
  >;
}) => {
  const mutationOptions = getQueryServiceQueryMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary Batch request with different queries
 */
export const queryServiceQueryBatch = (
  instanceId: string,
  queryServiceQueryBatchBody: QueryServiceQueryBatchBody,
) => {
  return httpClient<QueryServiceQueryBatch200>({
    url: `/v1/instances/${instanceId}/query/batch`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: queryServiceQueryBatchBody,
  });
};

export const getQueryServiceQueryBatchMutationOptions = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBatchBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>,
  TError,
  { instanceId: string; data: QueryServiceQueryBatchBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    { instanceId: string; data: QueryServiceQueryBatchBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return queryServiceQueryBatch(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type QueryServiceQueryBatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof queryServiceQueryBatch>>
>;
export type QueryServiceQueryBatchMutationBody = QueryServiceQueryBatchBody;
export type QueryServiceQueryBatchMutationError = ErrorType<RpcStatus>;

/**
 * @summary Batch request with different queries
 */
export const createQueryServiceQueryBatch = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof queryServiceQueryBatch>>,
    TError,
    { instanceId: string; data: QueryServiceQueryBatchBody },
    TContext
  >;
}) => {
  const mutationOptions = getQueryServiceQueryBatchMutationOptions(options);

  return createMutation(mutationOptions);
};
