/**
 * Generated by orval v6.12.0 üç∫
 * Do not edit manually.
 * rill/runtime/v1/export_format.proto
 * OpenAPI spec version: version not set
 */
import { createQuery, createMutation } from "@tanstack/svelte-query";
import type {
  CreateQueryOptions,
  CreateMutationOptions,
  QueryFunction,
  MutationFunction,
  CreateQueryResult,
  QueryKey,
} from "@tanstack/svelte-query";
import type {
  V1ListConnectorDriversResponse,
  RpcStatus,
  V1IssueDevJWTResponse,
  RuntimeServiceIssueDevJWTParams,
  V1ListExamplesResponse,
  V1ListInstancesResponse,
  RuntimeServiceListInstancesParams,
  V1CreateInstanceResponse,
  V1CreateInstanceRequest,
  V1GetInstanceResponse,
  RuntimeServiceGetInstanceParams,
  V1DeleteInstanceResponse,
  RuntimeServiceDeleteInstanceBody,
  V1EditInstanceResponse,
  RuntimeServiceEditInstanceBody,
  V1AnalyzeConnectorsResponse,
  V1ListNotifierConnectorsResponse,
  V1ListFilesResponse,
  RuntimeServiceListFilesParams,
  V1CreateDirectoryResponse,
  RuntimeServiceCreateDirectoryBody,
  V1GetFileResponse,
  RuntimeServiceGetFileParams,
  V1DeleteFileResponse,
  RuntimeServiceDeleteFileParams,
  V1PutFileResponse,
  RuntimeServicePutFileBody,
  V1GenerateMetricsViewFileResponse,
  RuntimeServiceGenerateMetricsViewFileBody,
  V1RenameFileResponse,
  RuntimeServiceRenameFileBody,
  V1UnpackEmptyResponse,
  RuntimeServiceUnpackEmptyBody,
  V1UnpackExampleResponse,
  RuntimeServiceUnpackExampleBody,
  RuntimeServiceWatchFiles200,
  RuntimeServiceWatchFilesParams,
  V1GenerateRendererResponse,
  RuntimeServiceGenerateRendererBody,
  V1GenerateResolverResponse,
  RuntimeServiceGenerateResolverBody,
  V1GetLogsResponse,
  RuntimeServiceGetLogsParams,
  RuntimeServiceWatchLogs200,
  RuntimeServiceWatchLogsParams,
  V1GetResourceResponse,
  RuntimeServiceGetResourceParams,
  V1ListResourcesResponse,
  RuntimeServiceListResourcesParams,
  RuntimeServiceWatchResources200,
  RuntimeServiceWatchResourcesParams,
  V1CreateTriggerResponse,
  RuntimeServiceCreateTriggerBody,
  V1PingResponse,
} from "../index.schemas";
import { httpClient } from "../../http-client";
import type { ErrorType } from "../../http-client";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary ListConnectorDrivers returns a description of all the connector drivers registed in the runtime,
including their configuration specs and the capabilities they support.
 */
export const runtimeServiceListConnectorDrivers = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorDriversResponse>({
    url: `/v1/connectors/meta`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListConnectorDriversQueryKey = () => [
  `/v1/connectors/meta`,
];

export type RuntimeServiceListConnectorDriversQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
>;
export type RuntimeServiceListConnectorDriversQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceListConnectorDrivers = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorDriversQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>
  > = ({ signal }) => runtimeServiceListConnectorDrivers(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListConnectorDrivers>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

export const runtimeServiceIssueDevJWT = (
  params?: RuntimeServiceIssueDevJWTParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1IssueDevJWTResponse>({
    url: `/v1/dev-jwt`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceIssueDevJWTQueryKey = (
  params?: RuntimeServiceIssueDevJWTParams,
) => [`/v1/dev-jwt`, ...(params ? [params] : [])];

export type RuntimeServiceIssueDevJWTQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
>;
export type RuntimeServiceIssueDevJWTQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceIssueDevJWT = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceIssueDevJWTParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceIssueDevJWTQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
  > = ({ signal }) => runtimeServiceIssueDevJWT(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export const runtimeServiceListExamples = (signal?: AbortSignal) => {
  return httpClient<V1ListExamplesResponse>({
    url: `/v1/examples`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListExamplesQueryKey = () => [`/v1/examples`];

export type RuntimeServiceListExamplesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>
>;
export type RuntimeServiceListExamplesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceListExamples = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListExamplesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>
  > = ({ signal }) => runtimeServiceListExamples(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams,
) => [`/v1/instances`, ...(params ? [params] : [])];

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceListInstances = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = ErrorType<RpcStatus>,
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListInstances>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest,
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
  });
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceCreateInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
) => [`/v1/instances/${instanceId}`, ...(params ? [params] : [])];

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceGetInstance = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetInstanceParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetInstanceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (
  instanceId: string,
  runtimeServiceDeleteInstanceBody: RuntimeServiceDeleteInstanceBody,
) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceDeleteInstanceBody,
  });
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;
export type RuntimeServiceDeleteInstanceMutationBody =
  RuntimeServiceDeleteInstanceBody;
export type RuntimeServiceDeleteInstanceMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceDeleteInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary EditInstance edits an existing instance
 */
export const runtimeServiceEditInstance = (
  instanceId: string,
  runtimeServiceEditInstanceBody: RuntimeServiceEditInstanceBody,
) => {
  return httpClient<V1EditInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceBody,
  });
};

export type RuntimeServiceEditInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>
>;
export type RuntimeServiceEditInstanceMutationBody =
  RuntimeServiceEditInstanceBody;
export type RuntimeServiceEditInstanceMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceEditInstance = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    { instanceId: string; data: RuntimeServiceEditInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstance(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary AnalyzeConnectors scans all the project files and returns information about all referenced connectors.
 */
export const runtimeServiceAnalyzeConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1AnalyzeConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/analyze`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceAnalyzeConnectorsQueryKey = (
  instanceId: string,
) => [`/v1/instances/${instanceId}/connectors/analyze`];

export type RuntimeServiceAnalyzeConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
>;
export type RuntimeServiceAnalyzeConnectorsQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceAnalyzeConnectors = <
  TData = Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceAnalyzeConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>
  > = ({ signal }) => runtimeServiceAnalyzeConnectors(instanceId, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceAnalyzeConnectors>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListNotifierConnectors returns the names of all configured connectors that can be used as notifiers.
This API is much faster than AnalyzeConnectors and can be called without admin-level permissions.
 */
export const runtimeServiceListNotifierConnectors = (
  instanceId: string,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListNotifierConnectorsResponse>({
    url: `/v1/instances/${instanceId}/connectors/notifiers`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListNotifierConnectorsQueryKey = (
  instanceId: string,
) => [`/v1/instances/${instanceId}/connectors/notifiers`];

export type RuntimeServiceListNotifierConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
>;
export type RuntimeServiceListNotifierConnectorsQueryError =
  ErrorType<RpcStatus>;

export const createRuntimeServiceListNotifierConnectors = <
  TData = Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListNotifierConnectorsQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>
  > = ({ signal }) => runtimeServiceListNotifierConnectors(instanceId, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListNotifierConnectors>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const runtimeServiceListFiles = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListFilesResponse>({
    url: `/v1/instances/${instanceId}/files`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
) => [`/v1/instances/${instanceId}/files`, ...(params ? [params] : [])];

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceListFiles = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListFiles>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateDirectory create a directory for the given path
 */
export const runtimeServiceCreateDirectory = (
  instanceId: string,
  runtimeServiceCreateDirectoryBody: RuntimeServiceCreateDirectoryBody,
) => {
  return httpClient<V1CreateDirectoryResponse>({
    url: `/v1/instances/${instanceId}/files/dir`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateDirectoryBody,
  });
};

export type RuntimeServiceCreateDirectoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>
>;
export type RuntimeServiceCreateDirectoryMutationBody =
  RuntimeServiceCreateDirectoryBody;
export type RuntimeServiceCreateDirectoryMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceCreateDirectory = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateDirectory(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateDirectory>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateDirectoryBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const runtimeServiceGetFile = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetFileQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
) => [`/v1/instances/${instanceId}/files/entry`, ...(params ? [params] : [])];

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceGetFile = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetFileParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetFile>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetFileQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const runtimeServiceDeleteFile = (
  instanceId: string,
  params?: RuntimeServiceDeleteFileParams,
) => {
  return httpClient<V1DeleteFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "delete",
    params,
  });
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceDeleteFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams }
  > = (props) => {
    const { instanceId, params } = props ?? {};

    return runtimeServiceDeleteFile(instanceId, params);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; params?: RuntimeServiceDeleteFileParams },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export const runtimeServicePutFile = (
  instanceId: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody,
) => {
  return httpClient<V1PutFileResponse>({
    url: `/v1/instances/${instanceId}/files/entry`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutFileBody,
  });
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = ErrorType<RpcStatus>;

export const createRuntimeServicePutFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { instanceId: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServicePutFile(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; data: RuntimeServicePutFileBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GenerateMetricsViewFile generates a metrics view YAML file from a table in an OLAP database
 */
export const runtimeServiceGenerateMetricsViewFile = (
  instanceId: string,
  runtimeServiceGenerateMetricsViewFileBody: RuntimeServiceGenerateMetricsViewFileBody,
) => {
  return httpClient<V1GenerateMetricsViewFileResponse>({
    url: `/v1/instances/${instanceId}/files/generate-metrics-view`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateMetricsViewFileBody,
  });
};

export type RuntimeServiceGenerateMetricsViewFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>
>;
export type RuntimeServiceGenerateMetricsViewFileMutationBody =
  RuntimeServiceGenerateMetricsViewFileBody;
export type RuntimeServiceGenerateMetricsViewFileMutationError =
  ErrorType<RpcStatus>;

export const createRuntimeServiceGenerateMetricsViewFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateMetricsViewFile(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceGenerateMetricsViewFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateMetricsViewFileBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary RenameFile renames a file in a repo
 */
export const runtimeServiceRenameFile = (
  instanceId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody,
) => {
  return httpClient<V1RenameFileResponse>({
    url: `/v1/instances/${instanceId}/files/rename`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceRenameFileBody,
  });
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceRenameFile = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { instanceId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceRenameFile(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const runtimeServiceUnpackEmpty = (
  instanceId: string,
  runtimeServiceUnpackEmptyBody: RuntimeServiceUnpackEmptyBody,
) => {
  return httpClient<V1UnpackEmptyResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-empty`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackEmptyBody,
  });
};

export type RuntimeServiceUnpackEmptyMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>
>;
export type RuntimeServiceUnpackEmptyMutationBody =
  RuntimeServiceUnpackEmptyBody;
export type RuntimeServiceUnpackEmptyMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceUnpackEmpty = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackEmpty(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary UnpackExample unpacks an example project
 */
export const runtimeServiceUnpackExample = (
  instanceId: string,
  runtimeServiceUnpackExampleBody: RuntimeServiceUnpackExampleBody,
) => {
  return httpClient<V1UnpackExampleResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-example`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackExampleBody,
  });
};

export type RuntimeServiceUnpackExampleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>
>;
export type RuntimeServiceUnpackExampleMutationBody =
  RuntimeServiceUnpackExampleBody;
export type RuntimeServiceUnpackExampleMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceUnpackExample = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackExample(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export const runtimeServiceWatchFiles = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchFiles200>({
    url: `/v1/instances/${instanceId}/files/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
) => [`/v1/instances/${instanceId}/files/watch`, ...(params ? [params] : [])];

export type RuntimeServiceWatchFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
>;
export type RuntimeServiceWatchFilesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceWatchFiles = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
  > = ({ signal }) => runtimeServiceWatchFiles(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GenerateRenderer generates a component renderer and renderer properties from a resolver and resolver properties
 */
export const runtimeServiceGenerateRenderer = (
  instanceId: string,
  runtimeServiceGenerateRendererBody: RuntimeServiceGenerateRendererBody,
) => {
  return httpClient<V1GenerateRendererResponse>({
    url: `/v1/instances/${instanceId}/generate/renderer`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateRendererBody,
  });
};

export type RuntimeServiceGenerateRendererMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>
>;
export type RuntimeServiceGenerateRendererMutationBody =
  RuntimeServiceGenerateRendererBody;
export type RuntimeServiceGenerateRendererMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceGenerateRenderer = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateRenderer(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceGenerateRenderer>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateRendererBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GenerateResolver generates resolver and resolver properties from a table or a metrics view
 */
export const runtimeServiceGenerateResolver = (
  instanceId: string,
  runtimeServiceGenerateResolverBody: RuntimeServiceGenerateResolverBody,
) => {
  return httpClient<V1GenerateResolverResponse>({
    url: `/v1/instances/${instanceId}/generate/resolver`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceGenerateResolverBody,
  });
};

export type RuntimeServiceGenerateResolverMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>
>;
export type RuntimeServiceGenerateResolverMutationBody =
  RuntimeServiceGenerateResolverBody;
export type RuntimeServiceGenerateResolverMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceGenerateResolver = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceGenerateResolver(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceGenerateResolver>>,
    TError,
    { instanceId: string; data: RuntimeServiceGenerateResolverBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary GetLogs returns recent logs from a controller
 */
export const runtimeServiceGetLogs = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetLogsResponse>({
    url: `/v1/instances/${instanceId}/logs`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
) => [`/v1/instances/${instanceId}/logs`, ...(params ? [params] : [])];

export type RuntimeServiceGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>
>;
export type RuntimeServiceGetLogsQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceGetLogs = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>
  > = ({ signal }) => runtimeServiceGetLogs(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export const runtimeServiceWatchLogs = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchLogs200>({
    url: `/v1/instances/${instanceId}/logs/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
) => [`/v1/instances/${instanceId}/logs/watch`, ...(params ? [params] : [])];

export type RuntimeServiceWatchLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
>;
export type RuntimeServiceWatchLogsQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceWatchLogs = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
  > = ({ signal }) => runtimeServiceWatchLogs(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary GetResource looks up a specific catalog resource
 */
export const runtimeServiceGetResource = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1GetResourceResponse>({
    url: `/v1/instances/${instanceId}/resource`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetResourceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
) => [`/v1/instances/${instanceId}/resource`, ...(params ? [params] : [])];

export type RuntimeServiceGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>
>;
export type RuntimeServiceGetResourceQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceGetResource = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetResource>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetResourceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>
  > = ({ signal }) => runtimeServiceGetResource(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export const runtimeServiceListResources = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<V1ListResourcesResponse>({
    url: `/v1/instances/${instanceId}/resources`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
) => [`/v1/instances/${instanceId}/resources`, ...(params ? [params] : [])];

export type RuntimeServiceListResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListResources>>
>;
export type RuntimeServiceListResourcesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceListResources = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListResources>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListResources>>
  > = ({ signal }) => runtimeServiceListResources(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceListResources>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export const runtimeServiceWatchResources = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  signal?: AbortSignal,
) => {
  return httpClient<RuntimeServiceWatchResources200>({
    url: `/v1/instances/${instanceId}/resources/-/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
) => [
  `/v1/instances/${instanceId}/resources/-/watch`,
  ...(params ? [params] : []),
];

export type RuntimeServiceWatchResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>
>;
export type RuntimeServiceWatchResourcesQueryError = ErrorType<RpcStatus>;

export const createRuntimeServiceWatchResources = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = ErrorType<RpcStatus>,
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
      TError,
      TData
    >;
  },
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>
  > = ({ signal }) => runtimeServiceWatchResources(instanceId, params, signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
    TError,
    TData
  >({
    queryKey,
    queryFn,
    enabled: !!instanceId,
    ...queryOptions,
  }) as CreateQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary CreateTrigger creates a trigger in the catalog.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const runtimeServiceCreateTrigger = (
  instanceId: string,
  runtimeServiceCreateTriggerBody: RuntimeServiceCreateTriggerBody,
) => {
  return httpClient<V1CreateTriggerResponse>({
    url: `/v1/instances/${instanceId}/trigger`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateTriggerBody,
  });
};

export type RuntimeServiceCreateTriggerMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>
>;
export type RuntimeServiceCreateTriggerMutationBody =
  RuntimeServiceCreateTriggerBody;
export type RuntimeServiceCreateTriggerMutationError = ErrorType<RpcStatus>;

export const createRuntimeServiceCreateTrigger = <
  TError = ErrorType<RpcStatus>,
  TContext = unknown,
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateTrigger(instanceId, data);
  };

  return createMutation<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >(mutationFn, mutationOptions);
};
/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "get", signal });
};

export const getRuntimeServicePingQueryKey = () => [`/v1/ping`];

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = ErrorType<RpcStatus>;

export const createRuntimeServicePing = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = ErrorType<RpcStatus>,
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  const query = createQuery<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >({ queryKey, queryFn, ...queryOptions }) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
