/**
 * Generated by orval v6.16.0 🍺
 * Do not edit manually.
 * rill/runtime/v1/schema.proto
 * OpenAPI spec version: version not set
 */
import { createQuery, createMutation } from "@tanstack/svelte-query";
import type {
  CreateQueryOptions,
  CreateMutationOptions,
  QueryFunction,
  MutationFunction,
  CreateQueryResult,
  QueryKey,
} from "@tanstack/svelte-query";
import type {
  V1ListConnectorsResponse,
  RpcStatus,
  V1DeleteFileAndReconcileResponse,
  V1DeleteFileAndReconcileRequest,
  V1IssueDevJWTResponse,
  RuntimeServiceIssueDevJWTParams,
  V1ListExamplesResponse,
  V1ListInstancesResponse,
  RuntimeServiceListInstancesParams,
  V1CreateInstanceResponse,
  V1CreateInstanceRequest,
  V1GetInstanceResponse,
  V1DeleteInstanceResponse,
  RuntimeServiceDeleteInstanceBody,
  V1EditInstanceVariablesResponse,
  RuntimeServiceEditInstanceVariablesBody,
  V1EditInstanceResponse,
  RuntimeServiceEditInstanceBody,
  V1EditInstanceAnnotationsResponse,
  RuntimeServiceEditInstanceAnnotationsBody,
  V1ListCatalogEntriesResponse,
  RuntimeServiceListCatalogEntriesParams,
  V1GetCatalogEntryResponse,
  V1TriggerRefreshResponse,
  V1ListFilesResponse,
  RuntimeServiceListFilesParams,
  V1GetFileResponse,
  V1DeleteFileResponse,
  V1PutFileResponse,
  RuntimeServicePutFileBody,
  V1RenameFileResponse,
  RuntimeServiceRenameFileBody,
  V1UnpackEmptyResponse,
  RuntimeServiceUnpackEmptyBody,
  V1UnpackExampleResponse,
  RuntimeServiceUnpackExampleBody,
  RuntimeServiceWatchFiles200,
  RuntimeServiceWatchFilesParams,
  V1GetLogsResponse,
  RuntimeServiceGetLogsParams,
  RuntimeServiceWatchLogs200,
  RuntimeServiceWatchLogsParams,
  V1ReconcileResponse,
  RuntimeServiceReconcileBody,
  V1GetResourceResponse,
  RuntimeServiceGetResourceParams,
  V1ListResourcesResponse,
  RuntimeServiceListResourcesParams,
  RuntimeServiceWatchResources200,
  RuntimeServiceWatchResourcesParams,
  V1TriggerSyncResponse,
  V1CreateTriggerResponse,
  RuntimeServiceCreateTriggerBody,
  V1PingResponse,
  V1PutFileAndReconcileResponse,
  V1PutFileAndReconcileRequest,
  V1RefreshAndReconcileResponse,
  V1RefreshAndReconcileRequest,
  V1RenameFileAndReconcileResponse,
  V1RenameFileAndReconcileRequest,
} from "../index.schemas";
import { httpClient } from "../../http-client";

/**
 * @summary ListConnectors returns a description of all the connectors implemented in the runtime,
including their schema and validation rules
 */
export const runtimeServiceListConnectors = (signal?: AbortSignal) => {
  return httpClient<V1ListConnectorsResponse>({
    url: `/v1/connectors/meta`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListConnectorsQueryKey = () =>
  [`/v1/connectors/meta`] as const;

export const getRuntimeServiceListConnectorsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >;
}): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListConnectorsQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>
  > = ({ signal }) => runtimeServiceListConnectors(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type RuntimeServiceListConnectorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListConnectors>>
>;
export type RuntimeServiceListConnectorsQueryError = RpcStatus;

/**
 * @summary ListConnectors returns a description of all the connectors implemented in the runtime,
including their schema and validation rules
 */
export const createRuntimeServiceListConnectors = <
  TData = Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListConnectors>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListConnectorsQueryOptions(options);

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary DeleteFileAndReconcile combines RenameFile and Reconcile in a single endpoint to reduce latency.
 */
export const runtimeServiceDeleteFileAndReconcile = (
  v1DeleteFileAndReconcileRequest: V1DeleteFileAndReconcileRequest
) => {
  return httpClient<V1DeleteFileAndReconcileResponse>({
    url: `/v1/delete-and-reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1DeleteFileAndReconcileRequest,
  });
};

export const getRuntimeServiceDeleteFileAndReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndReconcile>>,
    TError,
    { data: V1DeleteFileAndReconcileRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteFileAndReconcile>>,
  TError,
  { data: V1DeleteFileAndReconcileRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndReconcile>>,
    { data: V1DeleteFileAndReconcileRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceDeleteFileAndReconcile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteFileAndReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFileAndReconcile>>
>;
export type RuntimeServiceDeleteFileAndReconcileMutationBody =
  V1DeleteFileAndReconcileRequest;
export type RuntimeServiceDeleteFileAndReconcileMutationError = RpcStatus;

/**
 * @summary DeleteFileAndReconcile combines RenameFile and Reconcile in a single endpoint to reduce latency.
 */
export const createRuntimeServiceDeleteFileAndReconcile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFileAndReconcile>>,
    TError,
    { data: V1DeleteFileAndReconcileRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceDeleteFileAndReconcileMutationOptions(options);

  return createMutation(mutationOptions);
};
export const runtimeServiceIssueDevJWT = (
  params?: RuntimeServiceIssueDevJWTParams,
  signal?: AbortSignal
) => {
  return httpClient<V1IssueDevJWTResponse>({
    url: `/v1/dev-jwt`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceIssueDevJWTQueryKey = (
  params?: RuntimeServiceIssueDevJWTParams
) => [`/v1/dev-jwt`, ...(params ? [params] : [])] as const;

export const getRuntimeServiceIssueDevJWTQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceIssueDevJWTParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceIssueDevJWTQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
  > = ({ signal }) => runtimeServiceIssueDevJWT(params, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type RuntimeServiceIssueDevJWTQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>
>;
export type RuntimeServiceIssueDevJWTQueryError = RpcStatus;

export const createRuntimeServiceIssueDevJWT = <
  TData = Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceIssueDevJWTParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceIssueDevJWT>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceIssueDevJWTQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export const runtimeServiceListExamples = (signal?: AbortSignal) => {
  return httpClient<V1ListExamplesResponse>({
    url: `/v1/examples`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceListExamplesQueryKey = () =>
  [`/v1/examples`] as const;

export const getRuntimeServiceListExamplesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  >;
}): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListExamplesQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>
  > = ({ signal }) => runtimeServiceListExamples(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type RuntimeServiceListExamplesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListExamples>>
>;
export type RuntimeServiceListExamplesQueryError = RpcStatus;

/**
 * @summary ListExamples lists all the examples embedded into binary
 */
export const createRuntimeServiceListExamples = <
  TData = Awaited<ReturnType<typeof runtimeServiceListExamples>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServiceListExamples>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListExamplesQueryOptions(options);

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const runtimeServiceListInstances = (
  params?: RuntimeServiceListInstancesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListInstancesResponse>({
    url: `/v1/instances`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListInstancesQueryKey = (
  params?: RuntimeServiceListInstancesParams
) => [`/v1/instances`, ...(params ? [params] : [])] as const;

export const getRuntimeServiceListInstancesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListInstances>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceListInstancesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListInstances>>
  > = ({ signal }) => runtimeServiceListInstances(params, signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type RuntimeServiceListInstancesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListInstances>>
>;
export type RuntimeServiceListInstancesQueryError = RpcStatus;

/**
 * @summary ListInstances lists all the instances currently managed by the runtime
 */
export const createRuntimeServiceListInstances = <
  TData = Awaited<ReturnType<typeof runtimeServiceListInstances>>,
  TError = RpcStatus
>(
  params?: RuntimeServiceListInstancesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListInstances>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListInstancesQueryOptions(
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary CreateInstance creates a new instance
 */
export const runtimeServiceCreateInstance = (
  v1CreateInstanceRequest: V1CreateInstanceRequest
) => {
  return httpClient<V1CreateInstanceResponse>({
    url: `/v1/instances`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1CreateInstanceRequest,
  });
};

export const getRuntimeServiceCreateInstanceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
  TError,
  { data: V1CreateInstanceRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    { data: V1CreateInstanceRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceCreateInstance(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateInstance>>
>;
export type RuntimeServiceCreateInstanceMutationBody = V1CreateInstanceRequest;
export type RuntimeServiceCreateInstanceMutationError = RpcStatus;

/**
 * @summary CreateInstance creates a new instance
 */
export const createRuntimeServiceCreateInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateInstance>>,
    TError,
    { data: V1CreateInstanceRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceCreateInstanceMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary GetInstance returns information about a specific instance
 */
export const runtimeServiceGetInstance = (
  instanceId: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetInstanceQueryKey = (instanceId: string) =>
  [`/v1/instances/${instanceId}`] as const;

export const getRuntimeServiceGetInstanceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = RpcStatus
>(
  instanceId: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRuntimeServiceGetInstanceQueryKey(instanceId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetInstance>>
  > = ({ signal }) => runtimeServiceGetInstance(instanceId, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceGetInstanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetInstance>>
>;
export type RuntimeServiceGetInstanceQueryError = RpcStatus;

/**
 * @summary GetInstance returns information about a specific instance
 */
export const createRuntimeServiceGetInstance = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
  TError = RpcStatus
>(
  instanceId: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetInstance>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceGetInstanceQueryOptions(
    instanceId,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary DeleteInstance deletes an instance
 */
export const runtimeServiceDeleteInstance = (
  instanceId: string,
  runtimeServiceDeleteInstanceBody: RuntimeServiceDeleteInstanceBody
) => {
  return httpClient<V1DeleteInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceDeleteInstanceBody,
  });
};

export const getRuntimeServiceDeleteInstanceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceDeleteInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>
>;
export type RuntimeServiceDeleteInstanceMutationBody =
  RuntimeServiceDeleteInstanceBody;
export type RuntimeServiceDeleteInstanceMutationError = RpcStatus;

/**
 * @summary DeleteInstance deletes an instance
 */
export const createRuntimeServiceDeleteInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceDeleteInstanceBody },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceDeleteInstanceMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary EditInstanceVariables edits the instance variable
 */
export const runtimeServiceEditInstanceVariables = (
  instanceId: string,
  runtimeServiceEditInstanceVariablesBody: RuntimeServiceEditInstanceVariablesBody
) => {
  return httpClient<V1EditInstanceVariablesResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceVariablesBody,
  });
};

export const getRuntimeServiceEditInstanceVariablesMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceVariables>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceVariablesBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstanceVariables>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceVariablesBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceVariables>>,
    { instanceId: string; data: RuntimeServiceEditInstanceVariablesBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstanceVariables(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceVariablesMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstanceVariables>>
>;
export type RuntimeServiceEditInstanceVariablesMutationBody =
  RuntimeServiceEditInstanceVariablesBody;
export type RuntimeServiceEditInstanceVariablesMutationError = RpcStatus;

/**
 * @summary EditInstanceVariables edits the instance variable
 */
export const createRuntimeServiceEditInstanceVariables = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceVariables>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceVariablesBody },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceEditInstanceVariablesMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary EditInstance edits an existing instance
 */
export const runtimeServiceEditInstance = (
  instanceId: string,
  runtimeServiceEditInstanceBody: RuntimeServiceEditInstanceBody
) => {
  return httpClient<V1EditInstanceResponse>({
    url: `/v1/instances/${instanceId}`,
    method: "patch",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceBody,
  });
};

export const getRuntimeServiceEditInstanceMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    { instanceId: string; data: RuntimeServiceEditInstanceBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstance(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstance>>
>;
export type RuntimeServiceEditInstanceMutationBody =
  RuntimeServiceEditInstanceBody;
export type RuntimeServiceEditInstanceMutationError = RpcStatus;

/**
 * @summary EditInstance edits an existing instance
 */
export const createRuntimeServiceEditInstance = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstance>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceBody },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceEditInstanceMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary EditInstanceAnnotations edits the instance annotations
 */
export const runtimeServiceEditInstanceAnnotations = (
  instanceId: string,
  runtimeServiceEditInstanceAnnotationsBody: RuntimeServiceEditInstanceAnnotationsBody
) => {
  return httpClient<V1EditInstanceAnnotationsResponse>({
    url: `/v1/instances/${instanceId}/annotations`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceEditInstanceAnnotationsBody,
  });
};

export const getRuntimeServiceEditInstanceAnnotationsMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceAnnotations>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceAnnotationsBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceEditInstanceAnnotations>>,
  TError,
  { instanceId: string; data: RuntimeServiceEditInstanceAnnotationsBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceAnnotations>>,
    { instanceId: string; data: RuntimeServiceEditInstanceAnnotationsBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceEditInstanceAnnotations(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceEditInstanceAnnotationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceEditInstanceAnnotations>>
>;
export type RuntimeServiceEditInstanceAnnotationsMutationBody =
  RuntimeServiceEditInstanceAnnotationsBody;
export type RuntimeServiceEditInstanceAnnotationsMutationError = RpcStatus;

/**
 * @summary EditInstanceAnnotations edits the instance annotations
 */
export const createRuntimeServiceEditInstanceAnnotations = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceEditInstanceAnnotations>>,
    TError,
    { instanceId: string; data: RuntimeServiceEditInstanceAnnotationsBody },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceEditInstanceAnnotationsMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary ListCatalogEntries lists all the entries registered in an instance's catalog (like tables, sources or metrics views)
 */
export const runtimeServiceListCatalogEntries = (
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListCatalogEntriesResponse>({
    url: `/v1/instances/${instanceId}/catalog`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListCatalogEntriesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams
) =>
  [`/v1/instances/${instanceId}/catalog`, ...(params ? [params] : [])] as const;

export const getRuntimeServiceListCatalogEntriesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListCatalogEntriesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>
  > = ({ signal }) =>
    runtimeServiceListCatalogEntries(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceListCatalogEntriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>
>;
export type RuntimeServiceListCatalogEntriesQueryError = RpcStatus;

/**
 * @summary ListCatalogEntries lists all the entries registered in an instance's catalog (like tables, sources or metrics views)
 */
export const createRuntimeServiceListCatalogEntries = <
  TData = Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListCatalogEntriesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListCatalogEntries>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListCatalogEntriesQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary GetCatalogEntry returns information about a specific entry in the catalog
 */
export const runtimeServiceGetCatalogEntry = (
  instanceId: string,
  name: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetCatalogEntryResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetCatalogEntryQueryKey = (
  instanceId: string,
  name: string
) => [`/v1/instances/${instanceId}/catalog/${name}`] as const;

export const getRuntimeServiceGetCatalogEntryQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
  TError = RpcStatus
>(
  instanceId: string,
  name: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetCatalogEntryQueryKey(instanceId, name);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>
  > = ({ signal }) => runtimeServiceGetCatalogEntry(instanceId, name, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && name),
    ...queryOptions,
  };
};

export type RuntimeServiceGetCatalogEntryQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>
>;
export type RuntimeServiceGetCatalogEntryQueryError = RpcStatus;

/**
 * @summary GetCatalogEntry returns information about a specific entry in the catalog
 */
export const createRuntimeServiceGetCatalogEntry = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
  TError = RpcStatus
>(
  instanceId: string,
  name: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetCatalogEntry>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceGetCatalogEntryQueryOptions(
    instanceId,
    name,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary TriggerRefresh triggers a refresh of a refreshable catalog object.
It currently only supports sources (which will be re-ingested), but will also support materialized models in the future.
It does not respond until the refresh has completed (will move to async jobs when the task scheduler is in place).
 */
export const runtimeServiceTriggerRefresh = (
  instanceId: string,
  name: string
) => {
  return httpClient<V1TriggerRefreshResponse>({
    url: `/v1/instances/${instanceId}/catalog/${name}/refresh`,
    method: "post",
  });
};

export const getRuntimeServiceTriggerRefreshMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
  TError,
  { instanceId: string; name: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    { instanceId: string; name: string }
  > = (props) => {
    const { instanceId, name } = props ?? {};

    return runtimeServiceTriggerRefresh(instanceId, name);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceTriggerRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>
>;

export type RuntimeServiceTriggerRefreshMutationError = RpcStatus;

/**
 * @summary TriggerRefresh triggers a refresh of a refreshable catalog object.
It currently only supports sources (which will be re-ingested), but will also support materialized models in the future.
It does not respond until the refresh has completed (will move to async jobs when the task scheduler is in place).
 */
export const createRuntimeServiceTriggerRefresh = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerRefresh>>,
    TError,
    { instanceId: string; name: string },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceTriggerRefreshMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const runtimeServiceListFiles = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListFilesResponse>({
    url: `/v1/instances/${instanceId}/files`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListFilesParams
) =>
  [`/v1/instances/${instanceId}/files`, ...(params ? [params] : [])] as const;

export const getRuntimeServiceListFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListFiles>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListFiles>>
  > = ({ signal }) => runtimeServiceListFiles(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceListFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListFiles>>
>;
export type RuntimeServiceListFilesQueryError = RpcStatus;

/**
 * @summary ListFiles lists all the files matching a glob in a repo.
The files are sorted by their full path.
 */
export const createRuntimeServiceListFiles = <
  TData = Awaited<ReturnType<typeof runtimeServiceListFiles>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListFiles>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListFilesQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const runtimeServiceGetFile = (
  instanceId: string,
  path: string,
  signal?: AbortSignal
) => {
  return httpClient<V1GetFileResponse>({
    url: `/v1/instances/${instanceId}/files/-/${path}`,
    method: "get",
    signal,
  });
};

export const getRuntimeServiceGetFileQueryKey = (
  instanceId: string,
  path: string
) => [`/v1/instances/${instanceId}/files/-/${path}`] as const;

export const getRuntimeServiceGetFileQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = RpcStatus
>(
  instanceId: string,
  path: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetFile>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetFileQueryKey(instanceId, path);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetFile>>
  > = ({ signal }) => runtimeServiceGetFile(instanceId, path, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(instanceId && path),
    ...queryOptions,
  };
};

export type RuntimeServiceGetFileQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetFile>>
>;
export type RuntimeServiceGetFileQueryError = RpcStatus;

/**
 * @summary GetFile returns the contents of a specific file in a repo.
 */
export const createRuntimeServiceGetFile = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetFile>>,
  TError = RpcStatus
>(
  instanceId: string,
  path: string,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetFile>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceGetFileQueryOptions(
    instanceId,
    path,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const runtimeServiceDeleteFile = (instanceId: string, path: string) => {
  return httpClient<V1DeleteFileResponse>({
    url: `/v1/instances/${instanceId}/files/-/${path}`,
    method: "delete",
  });
};

export const getRuntimeServiceDeleteFileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; path: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
  TError,
  { instanceId: string; path: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    { instanceId: string; path: string }
  > = (props) => {
    const { instanceId, path } = props ?? {};

    return runtimeServiceDeleteFile(instanceId, path);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceDeleteFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceDeleteFile>>
>;

export type RuntimeServiceDeleteFileMutationError = RpcStatus;

/**
 * @summary DeleteFile deletes a file from a repo
 */
export const createRuntimeServiceDeleteFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceDeleteFile>>,
    TError,
    { instanceId: string; path: string },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceDeleteFileMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary PutFile creates or updates a file in a repo
 */
export const runtimeServicePutFile = (
  instanceId: string,
  path: string,
  runtimeServicePutFileBody: RuntimeServicePutFileBody
) => {
  return httpClient<V1PutFileResponse>({
    url: `/v1/instances/${instanceId}/files/-/${path}`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServicePutFileBody,
  });
};

export const getRuntimeServicePutFileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; path: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServicePutFile>>,
  TError,
  { instanceId: string; path: string; data: RuntimeServicePutFileBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    { instanceId: string; path: string; data: RuntimeServicePutFileBody }
  > = (props) => {
    const { instanceId, path, data } = props ?? {};

    return runtimeServicePutFile(instanceId, path, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServicePutFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFile>>
>;
export type RuntimeServicePutFileMutationBody = RuntimeServicePutFileBody;
export type RuntimeServicePutFileMutationError = RpcStatus;

/**
 * @summary PutFile creates or updates a file in a repo
 */
export const createRuntimeServicePutFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFile>>,
    TError,
    { instanceId: string; path: string; data: RuntimeServicePutFileBody },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServicePutFileMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary RenameFile renames a file in a repo
 */
export const runtimeServiceRenameFile = (
  instanceId: string,
  runtimeServiceRenameFileBody: RuntimeServiceRenameFileBody
) => {
  return httpClient<V1RenameFileResponse>({
    url: `/v1/instances/${instanceId}/files/rename`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceRenameFileBody,
  });
};

export const getRuntimeServiceRenameFileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
  TError,
  { instanceId: string; data: RuntimeServiceRenameFileBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    { instanceId: string; data: RuntimeServiceRenameFileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceRenameFile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRenameFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFile>>
>;
export type RuntimeServiceRenameFileMutationBody = RuntimeServiceRenameFileBody;
export type RuntimeServiceRenameFileMutationError = RpcStatus;

/**
 * @summary RenameFile renames a file in a repo
 */
export const createRuntimeServiceRenameFile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFile>>,
    TError,
    { instanceId: string; data: RuntimeServiceRenameFileBody },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceRenameFileMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const runtimeServiceUnpackEmpty = (
  instanceId: string,
  runtimeServiceUnpackEmptyBody: RuntimeServiceUnpackEmptyBody
) => {
  return httpClient<V1UnpackEmptyResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-empty`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackEmptyBody,
  });
};

export const getRuntimeServiceUnpackEmptyMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackEmpty(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackEmptyMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>
>;
export type RuntimeServiceUnpackEmptyMutationBody =
  RuntimeServiceUnpackEmptyBody;
export type RuntimeServiceUnpackEmptyMutationError = RpcStatus;

/**
 * @summary UnpackEmpty unpacks an empty project
 */
export const createRuntimeServiceUnpackEmpty = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackEmpty>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackEmptyBody },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceUnpackEmptyMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary UnpackExample unpacks an example project
 */
export const runtimeServiceUnpackExample = (
  instanceId: string,
  runtimeServiceUnpackExampleBody: RuntimeServiceUnpackExampleBody
) => {
  return httpClient<V1UnpackExampleResponse>({
    url: `/v1/instances/${instanceId}/files/unpack-example`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceUnpackExampleBody,
  });
};

export const getRuntimeServiceUnpackExampleMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
  TError,
  { instanceId: string; data: RuntimeServiceUnpackExampleBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceUnpackExample(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceUnpackExampleMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceUnpackExample>>
>;
export type RuntimeServiceUnpackExampleMutationBody =
  RuntimeServiceUnpackExampleBody;
export type RuntimeServiceUnpackExampleMutationError = RpcStatus;

/**
 * @summary UnpackExample unpacks an example project
 */
export const createRuntimeServiceUnpackExample = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceUnpackExample>>,
    TError,
    { instanceId: string; data: RuntimeServiceUnpackExampleBody },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceUnpackExampleMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export const runtimeServiceWatchFiles = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  signal?: AbortSignal
) => {
  return httpClient<RuntimeServiceWatchFiles200>({
    url: `/v1/instances/${instanceId}/files/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchFilesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams
) =>
  [
    `/v1/instances/${instanceId}/files/watch`,
    ...(params ? [params] : []),
  ] as const;

export const getRuntimeServiceWatchFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchFilesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
  > = ({ signal }) => runtimeServiceWatchFiles(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceWatchFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchFiles>>
>;
export type RuntimeServiceWatchFilesQueryError = RpcStatus;

/**
 * @summary WatchFiles streams repo file update events. It is not supported on all backends.
 */
export const createRuntimeServiceWatchFiles = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchFilesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchFiles>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceWatchFilesQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary GetLogs returns recent logs from a controller
 */
export const runtimeServiceGetLogs = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  signal?: AbortSignal
) => {
  return httpClient<V1GetLogsResponse>({
    url: `/v1/instances/${instanceId}/logs`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetLogsParams
) => [`/v1/instances/${instanceId}/logs`, ...(params ? [params] : [])] as const;

export const getRuntimeServiceGetLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetLogs>>
  > = ({ signal }) => runtimeServiceGetLogs(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceGetLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetLogs>>
>;
export type RuntimeServiceGetLogsQueryError = RpcStatus;

/**
 * @summary GetLogs returns recent logs from a controller
 */
export const createRuntimeServiceGetLogs = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceGetLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetLogs>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceGetLogsQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export const runtimeServiceWatchLogs = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  signal?: AbortSignal
) => {
  return httpClient<RuntimeServiceWatchLogs200>({
    url: `/v1/instances/${instanceId}/logs/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchLogsQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams
) =>
  [
    `/v1/instances/${instanceId}/logs/watch`,
    ...(params ? [params] : []),
  ] as const;

export const getRuntimeServiceWatchLogsQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchLogsQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
  > = ({ signal }) => runtimeServiceWatchLogs(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceWatchLogsQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchLogs>>
>;
export type RuntimeServiceWatchLogsQueryError = RpcStatus;

/**
 * @summary WatchLogs streams new logs emitted from a controller
 */
export const createRuntimeServiceWatchLogs = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchLogsParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchLogs>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceWatchLogsQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary Reconcile applies a full set of artifacts from a repo to the catalog and infra.
It attempts to infer a minimal number of migrations to apply to reconcile the current state with
the desired state expressed in the artifacts. Any existing objects not described in the submitted
artifacts will be deleted.
 */
export const runtimeServiceReconcile = (
  instanceId: string,
  runtimeServiceReconcileBody: RuntimeServiceReconcileBody
) => {
  return httpClient<V1ReconcileResponse>({
    url: `/v1/instances/${instanceId}/reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceReconcileBody,
  });
};

export const getRuntimeServiceReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceReconcile>>,
    TError,
    { instanceId: string; data: RuntimeServiceReconcileBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceReconcile>>,
  TError,
  { instanceId: string; data: RuntimeServiceReconcileBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceReconcile>>,
    { instanceId: string; data: RuntimeServiceReconcileBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceReconcile(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceReconcile>>
>;
export type RuntimeServiceReconcileMutationBody = RuntimeServiceReconcileBody;
export type RuntimeServiceReconcileMutationError = RpcStatus;

/**
 * @summary Reconcile applies a full set of artifacts from a repo to the catalog and infra.
It attempts to infer a minimal number of migrations to apply to reconcile the current state with
the desired state expressed in the artifacts. Any existing objects not described in the submitted
artifacts will be deleted.
 */
export const createRuntimeServiceReconcile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceReconcile>>,
    TError,
    { instanceId: string; data: RuntimeServiceReconcileBody },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceReconcileMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary GetResource looks up a specific catalog resource
 */
export const runtimeServiceGetResource = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  signal?: AbortSignal
) => {
  return httpClient<V1GetResourceResponse>({
    url: `/v1/instances/${instanceId}/resource`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceGetResourceQueryKey = (
  instanceId: string,
  params?: RuntimeServiceGetResourceParams
) =>
  [
    `/v1/instances/${instanceId}/resource`,
    ...(params ? [params] : []),
  ] as const;

export const getRuntimeServiceGetResourceQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetResource>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceGetResourceQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceGetResource>>
  > = ({ signal }) => runtimeServiceGetResource(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceGetResourceQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceGetResource>>
>;
export type RuntimeServiceGetResourceQueryError = RpcStatus;

/**
 * @summary GetResource looks up a specific catalog resource
 */
export const createRuntimeServiceGetResource = <
  TData = Awaited<ReturnType<typeof runtimeServiceGetResource>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceGetResourceParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceGetResource>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceGetResourceQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export const runtimeServiceListResources = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  signal?: AbortSignal
) => {
  return httpClient<V1ListResourcesResponse>({
    url: `/v1/instances/${instanceId}/resources`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceListResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceListResourcesParams
) =>
  [
    `/v1/instances/${instanceId}/resources`,
    ...(params ? [params] : []),
  ] as const;

export const getRuntimeServiceListResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListResources>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceListResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceListResources>>
  > = ({ signal }) => runtimeServiceListResources(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceListResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceListResources>>
>;
export type RuntimeServiceListResourcesQueryError = RpcStatus;

/**
 * @summary ListResources lists the resources stored in the catalog
 */
export const createRuntimeServiceListResources = <
  TData = Awaited<ReturnType<typeof runtimeServiceListResources>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceListResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceListResources>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceListResourcesQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export const runtimeServiceWatchResources = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  signal?: AbortSignal
) => {
  return httpClient<RuntimeServiceWatchResources200>({
    url: `/v1/instances/${instanceId}/resources/-/watch`,
    method: "get",
    params,
    signal,
  });
};

export const getRuntimeServiceWatchResourcesQueryKey = (
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams
) =>
  [
    `/v1/instances/${instanceId}/resources/-/watch`,
    ...(params ? [params] : []),
  ] as const;

export const getRuntimeServiceWatchResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
      TError,
      TData
    >;
  }
): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRuntimeServiceWatchResourcesQueryKey(instanceId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServiceWatchResources>>
  > = ({ signal }) => runtimeServiceWatchResources(instanceId, params, signal);

  return { queryKey, queryFn, enabled: !!instanceId, ...queryOptions };
};

export type RuntimeServiceWatchResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceWatchResources>>
>;
export type RuntimeServiceWatchResourcesQueryError = RpcStatus;

/**
 * @summary WatchResources streams updates to catalog resources (including creation and deletion events)
 */
export const createRuntimeServiceWatchResources = <
  TData = Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
  TError = RpcStatus
>(
  instanceId: string,
  params?: RuntimeServiceWatchResourcesParams,
  options?: {
    query?: CreateQueryOptions<
      Awaited<ReturnType<typeof runtimeServiceWatchResources>>,
      TError,
      TData
    >;
  }
): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServiceWatchResourcesQueryOptions(
    instanceId,
    params,
    options
  );

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary TriggerSync syncronizes the instance's catalog with the underlying OLAP's information schema.
If the instance has exposed=true, tables found in the information schema will be added to the catalog.
 */
export const runtimeServiceTriggerSync = (instanceId: string) => {
  return httpClient<V1TriggerSyncResponse>({
    url: `/v1/instances/${instanceId}/sync`,
    method: "post",
  });
};

export const getRuntimeServiceTriggerSyncMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
  TError,
  { instanceId: string },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    { instanceId: string }
  > = (props) => {
    const { instanceId } = props ?? {};

    return runtimeServiceTriggerSync(instanceId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceTriggerSyncMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceTriggerSync>>
>;

export type RuntimeServiceTriggerSyncMutationError = RpcStatus;

/**
 * @summary TriggerSync syncronizes the instance's catalog with the underlying OLAP's information schema.
If the instance has exposed=true, tables found in the information schema will be added to the catalog.
 */
export const createRuntimeServiceTriggerSync = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceTriggerSync>>,
    TError,
    { instanceId: string },
    TContext
  >;
}) => {
  const mutationOptions = getRuntimeServiceTriggerSyncMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary CreateTrigger creates a trigger in the catalog.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const runtimeServiceCreateTrigger = (
  instanceId: string,
  runtimeServiceCreateTriggerBody: RuntimeServiceCreateTriggerBody
) => {
  return httpClient<V1CreateTriggerResponse>({
    url: `/v1/instances/${instanceId}/trigger`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: runtimeServiceCreateTriggerBody,
  });
};

export const getRuntimeServiceCreateTriggerMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
  TError,
  { instanceId: string; data: RuntimeServiceCreateTriggerBody },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody }
  > = (props) => {
    const { instanceId, data } = props ?? {};

    return runtimeServiceCreateTrigger(instanceId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceCreateTriggerMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>
>;
export type RuntimeServiceCreateTriggerMutationBody =
  RuntimeServiceCreateTriggerBody;
export type RuntimeServiceCreateTriggerMutationError = RpcStatus;

/**
 * @summary CreateTrigger creates a trigger in the catalog.
Triggers are ephemeral resources that will be cleaned up by the controller.
 */
export const createRuntimeServiceCreateTrigger = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceCreateTrigger>>,
    TError,
    { instanceId: string; data: RuntimeServiceCreateTriggerBody },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceCreateTriggerMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary Ping returns information about the runtime
 */
export const runtimeServicePing = (signal?: AbortSignal) => {
  return httpClient<V1PingResponse>({ url: `/v1/ping`, method: "get", signal });
};

export const getRuntimeServicePingQueryKey = () => [`/v1/ping`] as const;

export const getRuntimeServicePingQueryOptions = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >;
}): CreateQueryOptions<
  Awaited<ReturnType<typeof runtimeServicePing>>,
  TError,
  TData
> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRuntimeServicePingQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof runtimeServicePing>>
  > = ({ signal }) => runtimeServicePing(signal);

  return { queryKey, queryFn, ...queryOptions };
};

export type RuntimeServicePingQueryResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePing>>
>;
export type RuntimeServicePingQueryError = RpcStatus;

/**
 * @summary Ping returns information about the runtime
 */
export const createRuntimeServicePing = <
  TData = Awaited<ReturnType<typeof runtimeServicePing>>,
  TError = RpcStatus
>(options?: {
  query?: CreateQueryOptions<
    Awaited<ReturnType<typeof runtimeServicePing>>,
    TError,
    TData
  >;
}): CreateQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRuntimeServicePingQueryOptions(options);

  const query = createQuery(queryOptions) as CreateQueryResult<
    TData,
    TError
  > & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
};

/**
 * @summary PutFileAndReconcile combines PutFile and Reconcile in a single endpoint to reduce latency.
It is equivalent to calling the two RPCs sequentially.
 */
export const runtimeServicePutFileAndReconcile = (
  v1PutFileAndReconcileRequest: V1PutFileAndReconcileRequest
) => {
  return httpClient<V1PutFileAndReconcileResponse>({
    url: `/v1/put-and-reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1PutFileAndReconcileRequest,
  });
};

export const getRuntimeServicePutFileAndReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFileAndReconcile>>,
    TError,
    { data: V1PutFileAndReconcileRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServicePutFileAndReconcile>>,
  TError,
  { data: V1PutFileAndReconcileRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServicePutFileAndReconcile>>,
    { data: V1PutFileAndReconcileRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServicePutFileAndReconcile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServicePutFileAndReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServicePutFileAndReconcile>>
>;
export type RuntimeServicePutFileAndReconcileMutationBody =
  V1PutFileAndReconcileRequest;
export type RuntimeServicePutFileAndReconcileMutationError = RpcStatus;

/**
 * @summary PutFileAndReconcile combines PutFile and Reconcile in a single endpoint to reduce latency.
It is equivalent to calling the two RPCs sequentially.
 */
export const createRuntimeServicePutFileAndReconcile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServicePutFileAndReconcile>>,
    TError,
    { data: V1PutFileAndReconcileRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServicePutFileAndReconcileMutationOptions(options);

  return createMutation(mutationOptions);
};
export const runtimeServiceRefreshAndReconcile = (
  v1RefreshAndReconcileRequest: V1RefreshAndReconcileRequest
) => {
  return httpClient<V1RefreshAndReconcileResponse>({
    url: `/v1/refresh-and-reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1RefreshAndReconcileRequest,
  });
};

export const getRuntimeServiceRefreshAndReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRefreshAndReconcile>>,
    TError,
    { data: V1RefreshAndReconcileRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRefreshAndReconcile>>,
  TError,
  { data: V1RefreshAndReconcileRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRefreshAndReconcile>>,
    { data: V1RefreshAndReconcileRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceRefreshAndReconcile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRefreshAndReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRefreshAndReconcile>>
>;
export type RuntimeServiceRefreshAndReconcileMutationBody =
  V1RefreshAndReconcileRequest;
export type RuntimeServiceRefreshAndReconcileMutationError = RpcStatus;

export const createRuntimeServiceRefreshAndReconcile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRefreshAndReconcile>>,
    TError,
    { data: V1RefreshAndReconcileRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceRefreshAndReconcileMutationOptions(options);

  return createMutation(mutationOptions);
};
/**
 * @summary RenameFileAndReconcile combines RenameFile and Reconcile in a single endpoint to reduce latency.
 */
export const runtimeServiceRenameFileAndReconcile = (
  v1RenameFileAndReconcileRequest: V1RenameFileAndReconcileRequest
) => {
  return httpClient<V1RenameFileAndReconcileResponse>({
    url: `/v1/rename-and-reconcile`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: v1RenameFileAndReconcileRequest,
  });
};

export const getRuntimeServiceRenameFileAndReconcileMutationOptions = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndReconcile>>,
    TError,
    { data: V1RenameFileAndReconcileRequest },
    TContext
  >;
}): CreateMutationOptions<
  Awaited<ReturnType<typeof runtimeServiceRenameFileAndReconcile>>,
  TError,
  { data: V1RenameFileAndReconcileRequest },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndReconcile>>,
    { data: V1RenameFileAndReconcileRequest }
  > = (props) => {
    const { data } = props ?? {};

    return runtimeServiceRenameFileAndReconcile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RuntimeServiceRenameFileAndReconcileMutationResult = NonNullable<
  Awaited<ReturnType<typeof runtimeServiceRenameFileAndReconcile>>
>;
export type RuntimeServiceRenameFileAndReconcileMutationBody =
  V1RenameFileAndReconcileRequest;
export type RuntimeServiceRenameFileAndReconcileMutationError = RpcStatus;

/**
 * @summary RenameFileAndReconcile combines RenameFile and Reconcile in a single endpoint to reduce latency.
 */
export const createRuntimeServiceRenameFileAndReconcile = <
  TError = RpcStatus,
  TContext = unknown
>(options?: {
  mutation?: CreateMutationOptions<
    Awaited<ReturnType<typeof runtimeServiceRenameFileAndReconcile>>,
    TError,
    { data: V1RenameFileAndReconcileRequest },
    TContext
  >;
}) => {
  const mutationOptions =
    getRuntimeServiceRenameFileAndReconcileMutationOptions(options);

  return createMutation(mutationOptions);
};
