// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rill/runtime/v1/resources.proto

package runtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Resource with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Resource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMultiError, or nil
// if none found.
func (m *Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Resource.(type) {
	case *Resource_ProjectParser:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetProjectParser()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ProjectParser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "ProjectParser",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetProjectParser()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "ProjectParser",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Source:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Model:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetModel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_MetricsView:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsView()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsView()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "MetricsView",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Migration:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMigration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Migration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Migration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMigration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Migration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Report:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReport()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Report",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Report",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReport()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Report",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Alert:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAlert()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Alert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Alert",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAlert()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Alert",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_PullTrigger:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPullTrigger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "PullTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "PullTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPullTrigger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "PullTrigger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_RefreshTrigger:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRefreshTrigger()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "RefreshTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "RefreshTrigger",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRefreshTrigger()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "RefreshTrigger",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_BucketPlanner:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBucketPlanner()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "BucketPlanner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "BucketPlanner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBucketPlanner()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "BucketPlanner",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Theme:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTheme()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Theme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Theme",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTheme()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Theme",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Component:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComponent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Component",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Component",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComponent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Component",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Dashboard:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDashboard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Dashboard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Dashboard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDashboard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Dashboard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Api:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Api",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Resource_Connector:
		if v == nil {
			err := ResourceValidationError{
				field:  "Resource",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnector()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Connector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceValidationError{
						field:  "Connector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnector()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceValidationError{
					field:  "Connector",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResourceMultiError(errors)
	}

	return nil
}

// ResourceMultiError is an error wrapping multiple validation errors returned
// by Resource.ValidateAll() if the designated constraints aren't met.
type ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMultiError) AllErrors() []error { return m }

// ResourceValidationError is the validation error returned by
// Resource.Validate if the designated constraints aren't met.
type ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceValidationError) ErrorName() string { return "ResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceValidationError{}

// Validate checks the field values on ResourceMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceMetaMultiError, or
// nil if none found.
func (m *ResourceMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetName()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "Name",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetRefs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  fmt.Sprintf("Refs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Hidden

	// no validation rules for Version

	// no validation rules for SpecVersion

	// no validation rules for StateVersion

	if all {
		switch v := interface{}(m.GetCreatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "CreatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpecUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "SpecUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "SpecUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "SpecUpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStateUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "StateUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "StateUpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStateUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "StateUpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReconcileStatus

	// no validation rules for ReconcileError

	if all {
		switch v := interface{}(m.GetReconcileOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "ReconcileOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceMetaValidationError{
					field:  "ReconcileOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReconcileOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceMetaValidationError{
				field:  "ReconcileOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Owner != nil {

		if all {
			switch v := interface{}(m.GetOwner()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "Owner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "Owner",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOwner()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "Owner",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DeletedOn != nil {

		if all {
			switch v := interface{}(m.GetDeletedOn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "DeletedOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "DeletedOn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeletedOn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "DeletedOn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RenamedFrom != nil {

		if all {
			switch v := interface{}(m.GetRenamedFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "RenamedFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResourceMetaValidationError{
						field:  "RenamedFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRenamedFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResourceMetaValidationError{
					field:  "RenamedFrom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResourceMetaMultiError(errors)
	}

	return nil
}

// ResourceMetaMultiError is an error wrapping multiple validation errors
// returned by ResourceMeta.ValidateAll() if the designated constraints aren't met.
type ResourceMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceMetaMultiError) AllErrors() []error { return m }

// ResourceMetaValidationError is the validation error returned by
// ResourceMeta.Validate if the designated constraints aren't met.
type ResourceMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceMetaValidationError) ErrorName() string { return "ResourceMetaValidationError" }

// Error satisfies the builtin error interface
func (e ResourceMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceMetaValidationError{}

// Validate checks the field values on ResourceName with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceName with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceNameMultiError, or
// nil if none found.
func (m *ResourceName) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Name

	if len(errors) > 0 {
		return ResourceNameMultiError(errors)
	}

	return nil
}

// ResourceNameMultiError is an error wrapping multiple validation errors
// returned by ResourceName.ValidateAll() if the designated constraints aren't met.
type ResourceNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceNameMultiError) AllErrors() []error { return m }

// ResourceNameValidationError is the validation error returned by
// ResourceName.Validate if the designated constraints aren't met.
type ResourceNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceNameValidationError) ErrorName() string { return "ResourceNameValidationError" }

// Error satisfies the builtin error interface
func (e ResourceNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceNameValidationError{}

// Validate checks the field values on ProjectParser with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectParser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParser with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectParserMultiError, or
// nil if none found.
func (m *ProjectParser) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectParserValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectParserValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectParserValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectParserMultiError(errors)
	}

	return nil
}

// ProjectParserMultiError is an error wrapping multiple validation errors
// returned by ProjectParser.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserMultiError) AllErrors() []error { return m }

// ProjectParserValidationError is the validation error returned by
// ProjectParser.Validate if the designated constraints aren't met.
type ProjectParserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserValidationError) ErrorName() string { return "ProjectParserValidationError" }

// Error satisfies the builtin error interface
func (e ProjectParserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserValidationError{}

// Validate checks the field values on ProjectParserSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProjectParserSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParserSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectParserSpecMultiError, or nil if none found.
func (m *ProjectParserSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParserSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ProjectParserSpecMultiError(errors)
	}

	return nil
}

// ProjectParserSpecMultiError is an error wrapping multiple validation errors
// returned by ProjectParserSpec.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserSpecMultiError) AllErrors() []error { return m }

// ProjectParserSpecValidationError is the validation error returned by
// ProjectParserSpec.Validate if the designated constraints aren't met.
type ProjectParserSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserSpecValidationError) ErrorName() string {
	return "ProjectParserSpecValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectParserSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParserSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserSpecValidationError{}

// Validate checks the field values on ProjectParserState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProjectParserState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectParserState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectParserStateMultiError, or nil if none found.
func (m *ProjectParserState) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectParserState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetParseErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProjectParserStateValidationError{
						field:  fmt.Sprintf("ParseErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProjectParserStateValidationError{
						field:  fmt.Sprintf("ParseErrors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProjectParserStateValidationError{
					field:  fmt.Sprintf("ParseErrors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CurrentCommitSha

	// no validation rules for Watching

	if len(errors) > 0 {
		return ProjectParserStateMultiError(errors)
	}

	return nil
}

// ProjectParserStateMultiError is an error wrapping multiple validation errors
// returned by ProjectParserState.ValidateAll() if the designated constraints
// aren't met.
type ProjectParserStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectParserStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectParserStateMultiError) AllErrors() []error { return m }

// ProjectParserStateValidationError is the validation error returned by
// ProjectParserState.Validate if the designated constraints aren't met.
type ProjectParserStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectParserStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectParserStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectParserStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectParserStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectParserStateValidationError) ErrorName() string {
	return "ProjectParserStateValidationError"
}

// Error satisfies the builtin error interface
func (e ProjectParserStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectParserState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectParserStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectParserStateValidationError{}

// Validate checks the field values on SourceV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceV2MultiError, or nil
// if none found.
func (m *SourceV2) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceV2ValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceV2ValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SourceV2MultiError(errors)
	}

	return nil
}

// SourceV2MultiError is an error wrapping multiple validation errors returned
// by SourceV2.ValidateAll() if the designated constraints aren't met.
type SourceV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceV2MultiError) AllErrors() []error { return m }

// SourceV2ValidationError is the validation error returned by
// SourceV2.Validate if the designated constraints aren't met.
type SourceV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceV2ValidationError) ErrorName() string { return "SourceV2ValidationError" }

// Error satisfies the builtin error interface
func (e SourceV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceV2ValidationError{}

// Validate checks the field values on SourceSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceSpecMultiError, or
// nil if none found.
func (m *SourceSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceConnector

	// no validation rules for SinkConnector

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceSpecValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for StageChanges

	// no validation rules for StreamIngestion

	// no validation rules for Trigger

	if len(errors) > 0 {
		return SourceSpecMultiError(errors)
	}

	return nil
}

// SourceSpecMultiError is an error wrapping multiple validation errors
// returned by SourceSpec.ValidateAll() if the designated constraints aren't met.
type SourceSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceSpecMultiError) AllErrors() []error { return m }

// SourceSpecValidationError is the validation error returned by
// SourceSpec.Validate if the designated constraints aren't met.
type SourceSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceSpecValidationError) ErrorName() string { return "SourceSpecValidationError" }

// Error satisfies the builtin error interface
func (e SourceSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceSpecValidationError{}

// Validate checks the field values on SourceState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourceState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourceState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourceStateMultiError, or
// nil if none found.
func (m *SourceState) ValidateAll() error {
	return m.validate(true)
}

func (m *SourceState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Table

	// no validation rules for SpecHash

	if all {
		switch v := interface{}(m.GetRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SourceStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SourceStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SourceStateValidationError{
				field:  "RefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SourceStateMultiError(errors)
	}

	return nil
}

// SourceStateMultiError is an error wrapping multiple validation errors
// returned by SourceState.ValidateAll() if the designated constraints aren't met.
type SourceStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceStateMultiError) AllErrors() []error { return m }

// SourceStateValidationError is the validation error returned by
// SourceState.Validate if the designated constraints aren't met.
type SourceStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceStateValidationError) ErrorName() string { return "SourceStateValidationError" }

// Error satisfies the builtin error interface
func (e SourceStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourceState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceStateValidationError{}

// Validate checks the field values on ModelV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ModelV2MultiError, or nil if none found.
func (m *ModelV2) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelV2ValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelV2ValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ModelV2MultiError(errors)
	}

	return nil
}

// ModelV2MultiError is an error wrapping multiple validation errors returned
// by ModelV2.ValidateAll() if the designated constraints aren't met.
type ModelV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelV2MultiError) AllErrors() []error { return m }

// ModelV2ValidationError is the validation error returned by ModelV2.Validate
// if the designated constraints aren't met.
type ModelV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelV2ValidationError) ErrorName() string { return "ModelV2ValidationError" }

// Error satisfies the builtin error interface
func (e ModelV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelV2ValidationError{}

// Validate checks the field values on ModelSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelSpecMultiError, or nil
// if none found.
func (m *ModelSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for Incremental

	// no validation rules for IncrementalStateResolver

	if all {
		switch v := interface{}(m.GetIncrementalStateResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "IncrementalStateResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "IncrementalStateResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalStateResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "IncrementalStateResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InputConnector

	if all {
		switch v := interface{}(m.GetInputProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "InputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "InputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInputProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "InputProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OutputConnector

	if all {
		switch v := interface{}(m.GetOutputProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "OutputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelSpecValidationError{
					field:  "OutputProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelSpecValidationError{
				field:  "OutputProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Trigger

	if len(errors) > 0 {
		return ModelSpecMultiError(errors)
	}

	return nil
}

// ModelSpecMultiError is an error wrapping multiple validation errors returned
// by ModelSpec.ValidateAll() if the designated constraints aren't met.
type ModelSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSpecMultiError) AllErrors() []error { return m }

// ModelSpecValidationError is the validation error returned by
// ModelSpec.Validate if the designated constraints aren't met.
type ModelSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSpecValidationError) ErrorName() string { return "ModelSpecValidationError" }

// Error satisfies the builtin error interface
func (e ModelSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSpecValidationError{}

// Validate checks the field values on ModelState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelStateMultiError, or
// nil if none found.
func (m *ModelState) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExecutorConnector

	// no validation rules for ResultConnector

	if all {
		switch v := interface{}(m.GetResultProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "ResultProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "ResultProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResultProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "ResultProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResultTable

	// no validation rules for SpecHash

	// no validation rules for RefsHash

	if all {
		switch v := interface{}(m.GetRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "RefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncrementalState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "IncrementalState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIncrementalStateSchema()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalStateSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelStateValidationError{
					field:  "IncrementalStateSchema",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIncrementalStateSchema()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelStateValidationError{
				field:  "IncrementalStateSchema",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ModelStateMultiError(errors)
	}

	return nil
}

// ModelStateMultiError is an error wrapping multiple validation errors
// returned by ModelState.ValidateAll() if the designated constraints aren't met.
type ModelStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelStateMultiError) AllErrors() []error { return m }

// ModelStateValidationError is the validation error returned by
// ModelState.Validate if the designated constraints aren't met.
type ModelStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelStateValidationError) ErrorName() string { return "ModelStateValidationError" }

// Error satisfies the builtin error interface
func (e ModelStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelStateValidationError{}

// Validate checks the field values on MetricsViewV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsViewV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewV2 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricsViewV2MultiError, or
// nil if none found.
func (m *MetricsViewV2) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewV2ValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewV2ValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetricsViewV2MultiError(errors)
	}

	return nil
}

// MetricsViewV2MultiError is an error wrapping multiple validation errors
// returned by MetricsViewV2.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewV2MultiError) AllErrors() []error { return m }

// MetricsViewV2ValidationError is the validation error returned by
// MetricsViewV2.Validate if the designated constraints aren't met.
type MetricsViewV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewV2ValidationError) ErrorName() string { return "MetricsViewV2ValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewV2ValidationError{}

// Validate checks the field values on MetricsViewSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpecMultiError, or nil if none found.
func (m *MetricsViewSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Database

	// no validation rules for DatabaseSchema

	// no validation rules for Table

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for TimeDimension

	// no validation rules for WatermarkExpression

	for idx, item := range m.GetDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Dimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("Dimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMeasures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("Measures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("Measures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SmallestTimeGrain

	// no validation rules for DefaultTimeRange

	if all {
		switch v := interface{}(m.GetSecurity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpecValidationError{
					field:  "Security",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpecValidationError{
					field:  "Security",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecurity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpecValidationError{
				field:  "Security",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FirstDayOfWeek

	// no validation rules for FirstMonthOfYear

	// no validation rules for DefaultComparisonMode

	// no validation rules for DefaultComparisonDimension

	for idx, item := range m.GetAvailableTimeRanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("AvailableTimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpecValidationError{
						field:  fmt.Sprintf("AvailableTimeRanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpecValidationError{
					field:  fmt.Sprintf("AvailableTimeRanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DefaultTheme

	if len(errors) > 0 {
		return MetricsViewSpecMultiError(errors)
	}

	return nil
}

// MetricsViewSpecMultiError is an error wrapping multiple validation errors
// returned by MetricsViewSpec.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpecMultiError) AllErrors() []error { return m }

// MetricsViewSpecValidationError is the validation error returned by
// MetricsViewSpec.Validate if the designated constraints aren't met.
type MetricsViewSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpecValidationError) ErrorName() string { return "MetricsViewSpecValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpecValidationError{}

// Validate checks the field values on MetricsViewState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewStateMultiError, or nil if none found.
func (m *MetricsViewState) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValidSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewStateValidationError{
					field:  "ValidSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewStateValidationError{
				field:  "ValidSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Streaming

	if len(errors) > 0 {
		return MetricsViewStateMultiError(errors)
	}

	return nil
}

// MetricsViewStateMultiError is an error wrapping multiple validation errors
// returned by MetricsViewState.ValidateAll() if the designated constraints
// aren't met.
type MetricsViewStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewStateMultiError) AllErrors() []error { return m }

// MetricsViewStateValidationError is the validation error returned by
// MetricsViewState.Validate if the designated constraints aren't met.
type MetricsViewStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewStateValidationError) ErrorName() string { return "MetricsViewStateValidationError" }

// Error satisfies the builtin error interface
func (e MetricsViewStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewStateValidationError{}

// Validate checks the field values on Migration with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Migration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Migration with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationMultiError, or nil
// if none found.
func (m *Migration) ValidateAll() error {
	return m.validate(true)
}

func (m *Migration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MigrationValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MigrationValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MigrationValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MigrationMultiError(errors)
	}

	return nil
}

// MigrationMultiError is an error wrapping multiple validation errors returned
// by Migration.ValidateAll() if the designated constraints aren't met.
type MigrationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationMultiError) AllErrors() []error { return m }

// MigrationValidationError is the validation error returned by
// Migration.Validate if the designated constraints aren't met.
type MigrationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationValidationError) ErrorName() string { return "MigrationValidationError" }

// Error satisfies the builtin error interface
func (e MigrationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationValidationError{}

// Validate checks the field values on MigrationSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MigrationSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrationSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationSpecMultiError, or
// nil if none found.
func (m *MigrationSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrationSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	// no validation rules for Sql

	// no validation rules for Version

	if len(errors) > 0 {
		return MigrationSpecMultiError(errors)
	}

	return nil
}

// MigrationSpecMultiError is an error wrapping multiple validation errors
// returned by MigrationSpec.ValidateAll() if the designated constraints
// aren't met.
type MigrationSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationSpecMultiError) AllErrors() []error { return m }

// MigrationSpecValidationError is the validation error returned by
// MigrationSpec.Validate if the designated constraints aren't met.
type MigrationSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationSpecValidationError) ErrorName() string { return "MigrationSpecValidationError" }

// Error satisfies the builtin error interface
func (e MigrationSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrationSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationSpecValidationError{}

// Validate checks the field values on MigrationState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MigrationState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MigrationState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MigrationStateMultiError,
// or nil if none found.
func (m *MigrationState) ValidateAll() error {
	return m.validate(true)
}

func (m *MigrationState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if len(errors) > 0 {
		return MigrationStateMultiError(errors)
	}

	return nil
}

// MigrationStateMultiError is an error wrapping multiple validation errors
// returned by MigrationState.ValidateAll() if the designated constraints
// aren't met.
type MigrationStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MigrationStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MigrationStateMultiError) AllErrors() []error { return m }

// MigrationStateValidationError is the validation error returned by
// MigrationState.Validate if the designated constraints aren't met.
type MigrationStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MigrationStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MigrationStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MigrationStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MigrationStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MigrationStateValidationError) ErrorName() string { return "MigrationStateValidationError" }

// Error satisfies the builtin error interface
func (e MigrationStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMigrationState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MigrationStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MigrationStateValidationError{}

// Validate checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Report) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Report with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ReportMultiError, or nil if none found.
func (m *Report) ValidateAll() error {
	return m.validate(true)
}

func (m *Report) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportMultiError(errors)
	}

	return nil
}

// ReportMultiError is an error wrapping multiple validation errors returned by
// Report.ValidateAll() if the designated constraints aren't met.
type ReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMultiError) AllErrors() []error { return m }

// ReportValidationError is the validation error returned by Report.Validate if
// the designated constraints aren't met.
type ReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportValidationError) ErrorName() string { return "ReportValidationError" }

// Error satisfies the builtin error interface
func (e ReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportValidationError{}

// Validate checks the field values on ReportSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportSpecMultiError, or
// nil if none found.
func (m *ReportSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Trigger

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimeoutSeconds

	// no validation rules for QueryName

	// no validation rules for QueryArgsJson

	// no validation rules for ExportLimit

	// no validation rules for ExportFormat

	for idx, item := range m.GetNotifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportSpecValidationError{
					field:  fmt.Sprintf("Notifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Annotations

	// no validation rules for WatermarkInherit

	// no validation rules for IntervalsIsoDuration

	// no validation rules for IntervalsLimit

	// no validation rules for IntervalsCheckUnclosed

	if len(errors) > 0 {
		return ReportSpecMultiError(errors)
	}

	return nil
}

// ReportSpecMultiError is an error wrapping multiple validation errors
// returned by ReportSpec.ValidateAll() if the designated constraints aren't met.
type ReportSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportSpecMultiError) AllErrors() []error { return m }

// ReportSpecValidationError is the validation error returned by
// ReportSpec.Validate if the designated constraints aren't met.
type ReportSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportSpecValidationError) ErrorName() string { return "ReportSpecValidationError" }

// Error satisfies the builtin error interface
func (e ReportSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportSpecValidationError{}

// Validate checks the field values on ReportState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReportState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReportStateMultiError, or
// nil if none found.
func (m *ReportState) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNextRunOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextRunOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportStateValidationError{
				field:  "NextRunOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportStateValidationError{
				field:  "CurrentExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExecutionHistory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportStateValidationError{
					field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExecutionCount

	if len(errors) > 0 {
		return ReportStateMultiError(errors)
	}

	return nil
}

// ReportStateMultiError is an error wrapping multiple validation errors
// returned by ReportState.ValidateAll() if the designated constraints aren't met.
type ReportStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportStateMultiError) AllErrors() []error { return m }

// ReportStateValidationError is the validation error returned by
// ReportState.Validate if the designated constraints aren't met.
type ReportStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportStateValidationError) ErrorName() string { return "ReportStateValidationError" }

// Error satisfies the builtin error interface
func (e ReportStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportStateValidationError{}

// Validate checks the field values on ReportExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReportExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportExecution with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportExecutionMultiError, or nil if none found.
func (m *ReportExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Adhoc

	// no validation rules for ErrorMessage

	if all {
		switch v := interface{}(m.GetReportTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "ReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "ReportTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "StartedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportExecutionValidationError{
				field:  "FinishedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReportExecutionMultiError(errors)
	}

	return nil
}

// ReportExecutionMultiError is an error wrapping multiple validation errors
// returned by ReportExecution.ValidateAll() if the designated constraints
// aren't met.
type ReportExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportExecutionMultiError) AllErrors() []error { return m }

// ReportExecutionValidationError is the validation error returned by
// ReportExecution.Validate if the designated constraints aren't met.
type ReportExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportExecutionValidationError) ErrorName() string { return "ReportExecutionValidationError" }

// Error satisfies the builtin error interface
func (e ReportExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportExecutionValidationError{}

// Validate checks the field values on Alert with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Alert) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Alert with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AlertMultiError, or nil if none found.
func (m *Alert) ValidateAll() error {
	return m.validate(true)
}

func (m *Alert) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlertMultiError(errors)
	}

	return nil
}

// AlertMultiError is an error wrapping multiple validation errors returned by
// Alert.ValidateAll() if the designated constraints aren't met.
type AlertMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertMultiError) AllErrors() []error { return m }

// AlertValidationError is the validation error returned by Alert.Validate if
// the designated constraints aren't met.
type AlertValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertValidationError) ErrorName() string { return "AlertValidationError" }

// Error satisfies the builtin error interface
func (e AlertValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlert.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertValidationError{}

// Validate checks the field values on AlertSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertSpecMultiError, or nil
// if none found.
func (m *AlertSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Trigger

	// no validation rules for Title

	if all {
		switch v := interface{}(m.GetRefreshSchedule()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertSpecValidationError{
					field:  "RefreshSchedule",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshSchedule()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertSpecValidationError{
				field:  "RefreshSchedule",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WatermarkInherit

	// no validation rules for IntervalsIsoDuration

	// no validation rules for IntervalsLimit

	// no validation rules for IntervalsCheckUnclosed

	// no validation rules for TimeoutSeconds

	// no validation rules for QueryName

	// no validation rules for QueryArgsJson

	// no validation rules for NotifyOnRecover

	// no validation rules for NotifyOnFail

	// no validation rules for NotifyOnError

	// no validation rules for Renotify

	// no validation rules for RenotifyAfterSeconds

	for idx, item := range m.GetNotifiers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  fmt.Sprintf("Notifiers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSpecValidationError{
					field:  fmt.Sprintf("Notifiers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Annotations

	switch v := m.QueryFor.(type) {
	case *AlertSpec_QueryForUserId:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for QueryForUserId
	case *AlertSpec_QueryForUserEmail:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for QueryForUserEmail
	case *AlertSpec_QueryForAttributes:
		if v == nil {
			err := AlertSpecValidationError{
				field:  "QueryFor",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetQueryForAttributes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  "QueryForAttributes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSpecValidationError{
						field:  "QueryForAttributes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetQueryForAttributes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSpecValidationError{
					field:  "QueryForAttributes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AlertSpecMultiError(errors)
	}

	return nil
}

// AlertSpecMultiError is an error wrapping multiple validation errors returned
// by AlertSpec.ValidateAll() if the designated constraints aren't met.
type AlertSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertSpecMultiError) AllErrors() []error { return m }

// AlertSpecValidationError is the validation error returned by
// AlertSpec.Validate if the designated constraints aren't met.
type AlertSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertSpecValidationError) ErrorName() string { return "AlertSpecValidationError" }

// Error satisfies the builtin error interface
func (e AlertSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertSpecValidationError{}

// Validate checks the field values on Notifier with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Notifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Notifier with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifierMultiError, or nil
// if none found.
func (m *Notifier) ValidateAll() error {
	return m.validate(true)
}

func (m *Notifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Connector

	if all {
		switch v := interface{}(m.GetProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NotifierValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NotifierValidationError{
					field:  "Properties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NotifierValidationError{
				field:  "Properties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NotifierMultiError(errors)
	}

	return nil
}

// NotifierMultiError is an error wrapping multiple validation errors returned
// by Notifier.ValidateAll() if the designated constraints aren't met.
type NotifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifierMultiError) AllErrors() []error { return m }

// NotifierValidationError is the validation error returned by
// Notifier.Validate if the designated constraints aren't met.
type NotifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifierValidationError) ErrorName() string { return "NotifierValidationError" }

// Error satisfies the builtin error interface
func (e NotifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifierValidationError{}

// Validate checks the field values on AlertState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertStateMultiError, or
// nil if none found.
func (m *AlertState) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpecHash

	// no validation rules for RefsHash

	if all {
		switch v := interface{}(m.GetNextRunOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "NextRunOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextRunOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertStateValidationError{
				field:  "NextRunOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertStateValidationError{
					field:  "CurrentExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertStateValidationError{
				field:  "CurrentExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExecutionHistory() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertStateValidationError{
						field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertStateValidationError{
					field:  fmt.Sprintf("ExecutionHistory[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ExecutionCount

	if len(errors) > 0 {
		return AlertStateMultiError(errors)
	}

	return nil
}

// AlertStateMultiError is an error wrapping multiple validation errors
// returned by AlertState.ValidateAll() if the designated constraints aren't met.
type AlertStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertStateMultiError) AllErrors() []error { return m }

// AlertStateValidationError is the validation error returned by
// AlertState.Validate if the designated constraints aren't met.
type AlertStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertStateValidationError) ErrorName() string { return "AlertStateValidationError" }

// Error satisfies the builtin error interface
func (e AlertStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertStateValidationError{}

// Validate checks the field values on AlertExecution with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertExecution) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertExecution with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertExecutionMultiError,
// or nil if none found.
func (m *AlertExecution) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertExecution) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Adhoc

	if all {
		switch v := interface{}(m.GetResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "Result",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "Result",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SentNotifications

	if all {
		switch v := interface{}(m.GetExecutionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "ExecutionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStartedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "StartedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "StartedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AlertExecutionValidationError{
					field:  "FinishedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AlertExecutionValidationError{
				field:  "FinishedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AlertExecutionMultiError(errors)
	}

	return nil
}

// AlertExecutionMultiError is an error wrapping multiple validation errors
// returned by AlertExecution.ValidateAll() if the designated constraints
// aren't met.
type AlertExecutionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertExecutionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertExecutionMultiError) AllErrors() []error { return m }

// AlertExecutionValidationError is the validation error returned by
// AlertExecution.Validate if the designated constraints aren't met.
type AlertExecutionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertExecutionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertExecutionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertExecutionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertExecutionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertExecutionValidationError) ErrorName() string { return "AlertExecutionValidationError" }

// Error satisfies the builtin error interface
func (e AlertExecutionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertExecution.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertExecutionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertExecutionValidationError{}

// Validate checks the field values on AssertionResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AssertionResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssertionResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssertionResultMultiError, or nil if none found.
func (m *AssertionResult) ValidateAll() error {
	return m.validate(true)
}

func (m *AssertionResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetFailRow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssertionResultValidationError{
					field:  "FailRow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssertionResultValidationError{
					field:  "FailRow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFailRow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssertionResultValidationError{
				field:  "FailRow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ErrorMessage

	if len(errors) > 0 {
		return AssertionResultMultiError(errors)
	}

	return nil
}

// AssertionResultMultiError is an error wrapping multiple validation errors
// returned by AssertionResult.ValidateAll() if the designated constraints
// aren't met.
type AssertionResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssertionResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssertionResultMultiError) AllErrors() []error { return m }

// AssertionResultValidationError is the validation error returned by
// AssertionResult.Validate if the designated constraints aren't met.
type AssertionResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssertionResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssertionResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssertionResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssertionResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssertionResultValidationError) ErrorName() string { return "AssertionResultValidationError" }

// Error satisfies the builtin error interface
func (e AssertionResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssertionResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssertionResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssertionResultValidationError{}

// Validate checks the field values on PullTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PullTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PullTriggerMultiError, or
// nil if none found.
func (m *PullTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *PullTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PullTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PullTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PullTriggerValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PullTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PullTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PullTriggerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PullTriggerMultiError(errors)
	}

	return nil
}

// PullTriggerMultiError is an error wrapping multiple validation errors
// returned by PullTrigger.ValidateAll() if the designated constraints aren't met.
type PullTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullTriggerMultiError) AllErrors() []error { return m }

// PullTriggerValidationError is the validation error returned by
// PullTrigger.Validate if the designated constraints aren't met.
type PullTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullTriggerValidationError) ErrorName() string { return "PullTriggerValidationError" }

// Error satisfies the builtin error interface
func (e PullTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullTriggerValidationError{}

// Validate checks the field values on PullTriggerSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PullTriggerSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullTriggerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PullTriggerSpecMultiError, or nil if none found.
func (m *PullTriggerSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *PullTriggerSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PullTriggerSpecMultiError(errors)
	}

	return nil
}

// PullTriggerSpecMultiError is an error wrapping multiple validation errors
// returned by PullTriggerSpec.ValidateAll() if the designated constraints
// aren't met.
type PullTriggerSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullTriggerSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullTriggerSpecMultiError) AllErrors() []error { return m }

// PullTriggerSpecValidationError is the validation error returned by
// PullTriggerSpec.Validate if the designated constraints aren't met.
type PullTriggerSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullTriggerSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullTriggerSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullTriggerSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullTriggerSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullTriggerSpecValidationError) ErrorName() string { return "PullTriggerSpecValidationError" }

// Error satisfies the builtin error interface
func (e PullTriggerSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullTriggerSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullTriggerSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullTriggerSpecValidationError{}

// Validate checks the field values on PullTriggerState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PullTriggerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PullTriggerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PullTriggerStateMultiError, or nil if none found.
func (m *PullTriggerState) ValidateAll() error {
	return m.validate(true)
}

func (m *PullTriggerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PullTriggerStateMultiError(errors)
	}

	return nil
}

// PullTriggerStateMultiError is an error wrapping multiple validation errors
// returned by PullTriggerState.ValidateAll() if the designated constraints
// aren't met.
type PullTriggerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PullTriggerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PullTriggerStateMultiError) AllErrors() []error { return m }

// PullTriggerStateValidationError is the validation error returned by
// PullTriggerState.Validate if the designated constraints aren't met.
type PullTriggerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PullTriggerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PullTriggerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PullTriggerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PullTriggerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PullTriggerStateValidationError) ErrorName() string { return "PullTriggerStateValidationError" }

// Error satisfies the builtin error interface
func (e PullTriggerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPullTriggerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PullTriggerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PullTriggerStateValidationError{}

// Validate checks the field values on RefreshTrigger with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefreshTrigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTrigger with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefreshTriggerMultiError,
// or nil if none found.
func (m *RefreshTrigger) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTrigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTriggerValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTriggerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTriggerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RefreshTriggerMultiError(errors)
	}

	return nil
}

// RefreshTriggerMultiError is an error wrapping multiple validation errors
// returned by RefreshTrigger.ValidateAll() if the designated constraints
// aren't met.
type RefreshTriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerMultiError) AllErrors() []error { return m }

// RefreshTriggerValidationError is the validation error returned by
// RefreshTrigger.Validate if the designated constraints aren't met.
type RefreshTriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerValidationError) ErrorName() string { return "RefreshTriggerValidationError" }

// Error satisfies the builtin error interface
func (e RefreshTriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerValidationError{}

// Validate checks the field values on RefreshTriggerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTriggerSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTriggerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTriggerSpecMultiError, or nil if none found.
func (m *RefreshTriggerSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTriggerSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOnlyNames() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("OnlyNames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTriggerSpecValidationError{
						field:  fmt.Sprintf("OnlyNames[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTriggerSpecValidationError{
					field:  fmt.Sprintf("OnlyNames[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTriggerSpecMultiError(errors)
	}

	return nil
}

// RefreshTriggerSpecMultiError is an error wrapping multiple validation errors
// returned by RefreshTriggerSpec.ValidateAll() if the designated constraints
// aren't met.
type RefreshTriggerSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerSpecMultiError) AllErrors() []error { return m }

// RefreshTriggerSpecValidationError is the validation error returned by
// RefreshTriggerSpec.Validate if the designated constraints aren't met.
type RefreshTriggerSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerSpecValidationError) ErrorName() string {
	return "RefreshTriggerSpecValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTriggerSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTriggerSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerSpecValidationError{}

// Validate checks the field values on RefreshTriggerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTriggerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTriggerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTriggerStateMultiError, or nil if none found.
func (m *RefreshTriggerState) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTriggerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RefreshTriggerStateMultiError(errors)
	}

	return nil
}

// RefreshTriggerStateMultiError is an error wrapping multiple validation
// errors returned by RefreshTriggerState.ValidateAll() if the designated
// constraints aren't met.
type RefreshTriggerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTriggerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTriggerStateMultiError) AllErrors() []error { return m }

// RefreshTriggerStateValidationError is the validation error returned by
// RefreshTriggerState.Validate if the designated constraints aren't met.
type RefreshTriggerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTriggerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTriggerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTriggerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTriggerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTriggerStateValidationError) ErrorName() string {
	return "RefreshTriggerStateValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTriggerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTriggerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTriggerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTriggerStateValidationError{}

// Validate checks the field values on BucketPlanner with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BucketPlanner) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketPlanner with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BucketPlannerMultiError, or
// nil if none found.
func (m *BucketPlanner) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketPlanner) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BucketPlannerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BucketPlannerValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BucketPlannerValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BucketPlannerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BucketPlannerValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BucketPlannerValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BucketPlannerMultiError(errors)
	}

	return nil
}

// BucketPlannerMultiError is an error wrapping multiple validation errors
// returned by BucketPlanner.ValidateAll() if the designated constraints
// aren't met.
type BucketPlannerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketPlannerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketPlannerMultiError) AllErrors() []error { return m }

// BucketPlannerValidationError is the validation error returned by
// BucketPlanner.Validate if the designated constraints aren't met.
type BucketPlannerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketPlannerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketPlannerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketPlannerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketPlannerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketPlannerValidationError) ErrorName() string { return "BucketPlannerValidationError" }

// Error satisfies the builtin error interface
func (e BucketPlannerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketPlanner.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketPlannerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketPlannerValidationError{}

// Validate checks the field values on BucketPlannerSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BucketPlannerSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketPlannerSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketPlannerSpecMultiError, or nil if none found.
func (m *BucketPlannerSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketPlannerSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExtractPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BucketPlannerSpecValidationError{
					field:  "ExtractPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BucketPlannerSpecValidationError{
					field:  "ExtractPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtractPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BucketPlannerSpecValidationError{
				field:  "ExtractPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BucketPlannerSpecMultiError(errors)
	}

	return nil
}

// BucketPlannerSpecMultiError is an error wrapping multiple validation errors
// returned by BucketPlannerSpec.ValidateAll() if the designated constraints
// aren't met.
type BucketPlannerSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketPlannerSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketPlannerSpecMultiError) AllErrors() []error { return m }

// BucketPlannerSpecValidationError is the validation error returned by
// BucketPlannerSpec.Validate if the designated constraints aren't met.
type BucketPlannerSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketPlannerSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketPlannerSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketPlannerSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketPlannerSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketPlannerSpecValidationError) ErrorName() string {
	return "BucketPlannerSpecValidationError"
}

// Error satisfies the builtin error interface
func (e BucketPlannerSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketPlannerSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketPlannerSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketPlannerSpecValidationError{}

// Validate checks the field values on BucketPlannerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BucketPlannerState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketPlannerState with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketPlannerStateMultiError, or nil if none found.
func (m *BucketPlannerState) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketPlannerState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	if len(errors) > 0 {
		return BucketPlannerStateMultiError(errors)
	}

	return nil
}

// BucketPlannerStateMultiError is an error wrapping multiple validation errors
// returned by BucketPlannerState.ValidateAll() if the designated constraints
// aren't met.
type BucketPlannerStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketPlannerStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketPlannerStateMultiError) AllErrors() []error { return m }

// BucketPlannerStateValidationError is the validation error returned by
// BucketPlannerState.Validate if the designated constraints aren't met.
type BucketPlannerStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketPlannerStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketPlannerStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketPlannerStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketPlannerStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketPlannerStateValidationError) ErrorName() string {
	return "BucketPlannerStateValidationError"
}

// Error satisfies the builtin error interface
func (e BucketPlannerStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketPlannerState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketPlannerStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketPlannerStateValidationError{}

// Validate checks the field values on BucketExtractPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BucketExtractPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BucketExtractPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BucketExtractPolicyMultiError, or nil if none found.
func (m *BucketExtractPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *BucketExtractPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RowsStrategy

	// no validation rules for RowsLimitBytes

	// no validation rules for FilesStrategy

	// no validation rules for FilesLimit

	if len(errors) > 0 {
		return BucketExtractPolicyMultiError(errors)
	}

	return nil
}

// BucketExtractPolicyMultiError is an error wrapping multiple validation
// errors returned by BucketExtractPolicy.ValidateAll() if the designated
// constraints aren't met.
type BucketExtractPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BucketExtractPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BucketExtractPolicyMultiError) AllErrors() []error { return m }

// BucketExtractPolicyValidationError is the validation error returned by
// BucketExtractPolicy.Validate if the designated constraints aren't met.
type BucketExtractPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BucketExtractPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BucketExtractPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BucketExtractPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BucketExtractPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BucketExtractPolicyValidationError) ErrorName() string {
	return "BucketExtractPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e BucketExtractPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBucketExtractPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BucketExtractPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BucketExtractPolicyValidationError{}

// Validate checks the field values on Theme with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Theme) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Theme with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ThemeMultiError, or nil if none found.
func (m *Theme) ValidateAll() error {
	return m.validate(true)
}

func (m *Theme) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThemeValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ThemeValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ThemeValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ThemeMultiError(errors)
	}

	return nil
}

// ThemeMultiError is an error wrapping multiple validation errors returned by
// Theme.ValidateAll() if the designated constraints aren't met.
type ThemeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeMultiError) AllErrors() []error { return m }

// ThemeValidationError is the validation error returned by Theme.Validate if
// the designated constraints aren't met.
type ThemeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeValidationError) ErrorName() string { return "ThemeValidationError" }

// Error satisfies the builtin error interface
func (e ThemeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTheme.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeValidationError{}

// Validate checks the field values on ThemeSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ThemeSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ThemeSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ThemeSpecMultiError, or nil
// if none found.
func (m *ThemeSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ThemeSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PrimaryColor != nil {

		if all {
			switch v := interface{}(m.GetPrimaryColor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "PrimaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "PrimaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrimaryColor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThemeSpecValidationError{
					field:  "PrimaryColor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.SecondaryColor != nil {

		if all {
			switch v := interface{}(m.GetSecondaryColor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "SecondaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ThemeSpecValidationError{
						field:  "SecondaryColor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecondaryColor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ThemeSpecValidationError{
					field:  "SecondaryColor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ThemeSpecMultiError(errors)
	}

	return nil
}

// ThemeSpecMultiError is an error wrapping multiple validation errors returned
// by ThemeSpec.ValidateAll() if the designated constraints aren't met.
type ThemeSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeSpecMultiError) AllErrors() []error { return m }

// ThemeSpecValidationError is the validation error returned by
// ThemeSpec.Validate if the designated constraints aren't met.
type ThemeSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeSpecValidationError) ErrorName() string { return "ThemeSpecValidationError" }

// Error satisfies the builtin error interface
func (e ThemeSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThemeSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeSpecValidationError{}

// Validate checks the field values on ThemeState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ThemeState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ThemeState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ThemeStateMultiError, or
// nil if none found.
func (m *ThemeState) ValidateAll() error {
	return m.validate(true)
}

func (m *ThemeState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ThemeStateMultiError(errors)
	}

	return nil
}

// ThemeStateMultiError is an error wrapping multiple validation errors
// returned by ThemeState.ValidateAll() if the designated constraints aren't met.
type ThemeStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ThemeStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ThemeStateMultiError) AllErrors() []error { return m }

// ThemeStateValidationError is the validation error returned by
// ThemeState.Validate if the designated constraints aren't met.
type ThemeStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ThemeStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ThemeStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ThemeStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ThemeStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ThemeStateValidationError) ErrorName() string { return "ThemeStateValidationError" }

// Error satisfies the builtin error interface
func (e ThemeStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sThemeState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ThemeStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ThemeStateValidationError{}

// Validate checks the field values on Component with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Component) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Component with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentMultiError, or nil
// if none found.
func (m *Component) ValidateAll() error {
	return m.validate(true)
}

func (m *Component) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComponentMultiError(errors)
	}

	return nil
}

// ComponentMultiError is an error wrapping multiple validation errors returned
// by Component.ValidateAll() if the designated constraints aren't met.
type ComponentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentMultiError) AllErrors() []error { return m }

// ComponentValidationError is the validation error returned by
// Component.Validate if the designated constraints aren't met.
type ComponentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentValidationError) ErrorName() string { return "ComponentValidationError" }

// Error satisfies the builtin error interface
func (e ComponentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentValidationError{}

// Validate checks the field values on ComponentSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComponentSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentSpecMultiError, or
// nil if none found.
func (m *ComponentSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentSpecValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Renderer

	if all {
		switch v := interface{}(m.GetRendererProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComponentSpecValidationError{
					field:  "RendererProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRendererProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComponentSpecValidationError{
				field:  "RendererProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefinedInDashboard

	// no validation rules for Subtitle

	if len(errors) > 0 {
		return ComponentSpecMultiError(errors)
	}

	return nil
}

// ComponentSpecMultiError is an error wrapping multiple validation errors
// returned by ComponentSpec.ValidateAll() if the designated constraints
// aren't met.
type ComponentSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentSpecMultiError) AllErrors() []error { return m }

// ComponentSpecValidationError is the validation error returned by
// ComponentSpec.Validate if the designated constraints aren't met.
type ComponentSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentSpecValidationError) ErrorName() string { return "ComponentSpecValidationError" }

// Error satisfies the builtin error interface
func (e ComponentSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentSpecValidationError{}

// Validate checks the field values on ComponentState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ComponentState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComponentState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ComponentStateMultiError,
// or nil if none found.
func (m *ComponentState) ValidateAll() error {
	return m.validate(true)
}

func (m *ComponentState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ComponentStateMultiError(errors)
	}

	return nil
}

// ComponentStateMultiError is an error wrapping multiple validation errors
// returned by ComponentState.ValidateAll() if the designated constraints
// aren't met.
type ComponentStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComponentStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComponentStateMultiError) AllErrors() []error { return m }

// ComponentStateValidationError is the validation error returned by
// ComponentState.Validate if the designated constraints aren't met.
type ComponentStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComponentStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComponentStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComponentStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComponentStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComponentStateValidationError) ErrorName() string { return "ComponentStateValidationError" }

// Error satisfies the builtin error interface
func (e ComponentStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComponentState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComponentStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComponentStateValidationError{}

// Validate checks the field values on Dashboard with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dashboard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dashboard with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardMultiError, or nil
// if none found.
func (m *Dashboard) ValidateAll() error {
	return m.validate(true)
}

func (m *Dashboard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DashboardValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DashboardValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DashboardValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DashboardMultiError(errors)
	}

	return nil
}

// DashboardMultiError is an error wrapping multiple validation errors returned
// by Dashboard.ValidateAll() if the designated constraints aren't met.
type DashboardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardMultiError) AllErrors() []error { return m }

// DashboardValidationError is the validation error returned by
// Dashboard.Validate if the designated constraints aren't met.
type DashboardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardValidationError) ErrorName() string { return "DashboardValidationError" }

// Error satisfies the builtin error interface
func (e DashboardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardValidationError{}

// Validate checks the field values on DashboardSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DashboardSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DashboardSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardSpecMultiError, or
// nil if none found.
func (m *DashboardSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *DashboardSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Columns

	// no validation rules for Gap

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DashboardSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DashboardSpecValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DashboardSpecValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DashboardSpecMultiError(errors)
	}

	return nil
}

// DashboardSpecMultiError is an error wrapping multiple validation errors
// returned by DashboardSpec.ValidateAll() if the designated constraints
// aren't met.
type DashboardSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardSpecMultiError) AllErrors() []error { return m }

// DashboardSpecValidationError is the validation error returned by
// DashboardSpec.Validate if the designated constraints aren't met.
type DashboardSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardSpecValidationError) ErrorName() string { return "DashboardSpecValidationError" }

// Error satisfies the builtin error interface
func (e DashboardSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboardSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardSpecValidationError{}

// Validate checks the field values on DashboardState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DashboardState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DashboardState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardStateMultiError,
// or nil if none found.
func (m *DashboardState) ValidateAll() error {
	return m.validate(true)
}

func (m *DashboardState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DashboardStateMultiError(errors)
	}

	return nil
}

// DashboardStateMultiError is an error wrapping multiple validation errors
// returned by DashboardState.ValidateAll() if the designated constraints
// aren't met.
type DashboardStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardStateMultiError) AllErrors() []error { return m }

// DashboardStateValidationError is the validation error returned by
// DashboardState.Validate if the designated constraints aren't met.
type DashboardStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardStateValidationError) ErrorName() string { return "DashboardStateValidationError" }

// Error satisfies the builtin error interface
func (e DashboardStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboardState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardStateValidationError{}

// Validate checks the field values on DashboardItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DashboardItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DashboardItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DashboardItemMultiError, or
// nil if none found.
func (m *DashboardItem) ValidateAll() error {
	return m.validate(true)
}

func (m *DashboardItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Component

	// no validation rules for DefinedInDashboard

	// no validation rules for FontSize

	if m.X != nil {
		// no validation rules for X
	}

	if m.Y != nil {
		// no validation rules for Y
	}

	if m.Width != nil {
		// no validation rules for Width
	}

	if m.Height != nil {
		// no validation rules for Height
	}

	if len(errors) > 0 {
		return DashboardItemMultiError(errors)
	}

	return nil
}

// DashboardItemMultiError is an error wrapping multiple validation errors
// returned by DashboardItem.ValidateAll() if the designated constraints
// aren't met.
type DashboardItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DashboardItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DashboardItemMultiError) AllErrors() []error { return m }

// DashboardItemValidationError is the validation error returned by
// DashboardItem.Validate if the designated constraints aren't met.
type DashboardItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DashboardItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DashboardItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DashboardItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DashboardItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DashboardItemValidationError) ErrorName() string { return "DashboardItemValidationError" }

// Error satisfies the builtin error interface
func (e DashboardItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDashboardItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DashboardItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DashboardItemValidationError{}

// Validate checks the field values on API with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *API) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on API with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in APIMultiError, or nil if none found.
func (m *API) ValidateAll() error {
	return m.validate(true)
}

func (m *API) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APIValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APIValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APIValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return APIMultiError(errors)
	}

	return nil
}

// APIMultiError is an error wrapping multiple validation errors returned by
// API.ValidateAll() if the designated constraints aren't met.
type APIMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIMultiError) AllErrors() []error { return m }

// APIValidationError is the validation error returned by API.Validate if the
// designated constraints aren't met.
type APIValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIValidationError) ErrorName() string { return "APIValidationError" }

// Error satisfies the builtin error interface
func (e APIValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPI.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIValidationError{}

// Validate checks the field values on APISpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APISpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APISpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in APISpecMultiError, or nil if none found.
func (m *APISpec) ValidateAll() error {
	return m.validate(true)
}

func (m *APISpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Resolver

	if all {
		switch v := interface{}(m.GetResolverProperties()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, APISpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, APISpecValidationError{
					field:  "ResolverProperties",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolverProperties()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return APISpecValidationError{
				field:  "ResolverProperties",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return APISpecMultiError(errors)
	}

	return nil
}

// APISpecMultiError is an error wrapping multiple validation errors returned
// by APISpec.ValidateAll() if the designated constraints aren't met.
type APISpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APISpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APISpecMultiError) AllErrors() []error { return m }

// APISpecValidationError is the validation error returned by APISpec.Validate
// if the designated constraints aren't met.
type APISpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APISpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APISpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APISpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APISpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APISpecValidationError) ErrorName() string { return "APISpecValidationError" }

// Error satisfies the builtin error interface
func (e APISpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPISpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APISpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APISpecValidationError{}

// Validate checks the field values on APIState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *APIState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on APIState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in APIStateMultiError, or nil
// if none found.
func (m *APIState) ValidateAll() error {
	return m.validate(true)
}

func (m *APIState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return APIStateMultiError(errors)
	}

	return nil
}

// APIStateMultiError is an error wrapping multiple validation errors returned
// by APIState.ValidateAll() if the designated constraints aren't met.
type APIStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m APIStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m APIStateMultiError) AllErrors() []error { return m }

// APIStateValidationError is the validation error returned by
// APIState.Validate if the designated constraints aren't met.
type APIStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e APIStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e APIStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e APIStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e APIStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e APIStateValidationError) ErrorName() string { return "APIStateValidationError" }

// Error satisfies the builtin error interface
func (e APIStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAPIState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = APIStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = APIStateValidationError{}

// Validate checks the field values on Schedule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Schedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Schedule with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScheduleMultiError, or nil
// if none found.
func (m *Schedule) ValidateAll() error {
	return m.validate(true)
}

func (m *Schedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RefUpdate

	// no validation rules for Disable

	// no validation rules for Cron

	// no validation rules for TickerSeconds

	// no validation rules for TimeZone

	if len(errors) > 0 {
		return ScheduleMultiError(errors)
	}

	return nil
}

// ScheduleMultiError is an error wrapping multiple validation errors returned
// by Schedule.ValidateAll() if the designated constraints aren't met.
type ScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScheduleMultiError) AllErrors() []error { return m }

// ScheduleValidationError is the validation error returned by
// Schedule.Validate if the designated constraints aren't met.
type ScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScheduleValidationError) ErrorName() string { return "ScheduleValidationError" }

// Error satisfies the builtin error interface
func (e ScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScheduleValidationError{}

// Validate checks the field values on ParseError with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParseError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseError with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParseErrorMultiError, or
// nil if none found.
func (m *ParseError) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for FilePath

	if all {
		switch v := interface{}(m.GetStartLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ParseErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ParseErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ParseErrorValidationError{
				field:  "StartLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for External

	if len(errors) > 0 {
		return ParseErrorMultiError(errors)
	}

	return nil
}

// ParseErrorMultiError is an error wrapping multiple validation errors
// returned by ParseError.ValidateAll() if the designated constraints aren't met.
type ParseErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseErrorMultiError) AllErrors() []error { return m }

// ParseErrorValidationError is the validation error returned by
// ParseError.Validate if the designated constraints aren't met.
type ParseErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseErrorValidationError) ErrorName() string { return "ParseErrorValidationError" }

// Error satisfies the builtin error interface
func (e ParseErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseErrorValidationError{}

// Validate checks the field values on ValidationError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ValidationError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidationError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidationErrorMultiError, or nil if none found.
func (m *ValidationError) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidationError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ValidationErrorMultiError(errors)
	}

	return nil
}

// ValidationErrorMultiError is an error wrapping multiple validation errors
// returned by ValidationError.ValidateAll() if the designated constraints
// aren't met.
type ValidationErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidationErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidationErrorMultiError) AllErrors() []error { return m }

// ValidationErrorValidationError is the validation error returned by
// ValidationError.Validate if the designated constraints aren't met.
type ValidationErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidationErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidationErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidationErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidationErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidationErrorValidationError) ErrorName() string { return "ValidationErrorValidationError" }

// Error satisfies the builtin error interface
func (e ValidationErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidationError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidationErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidationErrorValidationError{}

// Validate checks the field values on DependencyError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DependencyError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DependencyError with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DependencyErrorMultiError, or nil if none found.
func (m *DependencyError) ValidateAll() error {
	return m.validate(true)
}

func (m *DependencyError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Dependency

	if len(errors) > 0 {
		return DependencyErrorMultiError(errors)
	}

	return nil
}

// DependencyErrorMultiError is an error wrapping multiple validation errors
// returned by DependencyError.ValidateAll() if the designated constraints
// aren't met.
type DependencyErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DependencyErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DependencyErrorMultiError) AllErrors() []error { return m }

// DependencyErrorValidationError is the validation error returned by
// DependencyError.Validate if the designated constraints aren't met.
type DependencyErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DependencyErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DependencyErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DependencyErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DependencyErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DependencyErrorValidationError) ErrorName() string { return "DependencyErrorValidationError" }

// Error satisfies the builtin error interface
func (e DependencyErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDependencyError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DependencyErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DependencyErrorValidationError{}

// Validate checks the field values on ExecutionError with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecutionError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecutionError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecutionErrorMultiError,
// or nil if none found.
func (m *ExecutionError) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecutionError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ExecutionErrorMultiError(errors)
	}

	return nil
}

// ExecutionErrorMultiError is an error wrapping multiple validation errors
// returned by ExecutionError.ValidateAll() if the designated constraints
// aren't met.
type ExecutionErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecutionErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecutionErrorMultiError) AllErrors() []error { return m }

// ExecutionErrorValidationError is the validation error returned by
// ExecutionError.Validate if the designated constraints aren't met.
type ExecutionErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecutionErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecutionErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecutionErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecutionErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecutionErrorValidationError) ErrorName() string { return "ExecutionErrorValidationError" }

// Error satisfies the builtin error interface
func (e ExecutionErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecutionError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecutionErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecutionErrorValidationError{}

// Validate checks the field values on CharLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CharLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CharLocation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CharLocationMultiError, or
// nil if none found.
func (m *CharLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *CharLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Line

	if len(errors) > 0 {
		return CharLocationMultiError(errors)
	}

	return nil
}

// CharLocationMultiError is an error wrapping multiple validation errors
// returned by CharLocation.ValidateAll() if the designated constraints aren't met.
type CharLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CharLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CharLocationMultiError) AllErrors() []error { return m }

// CharLocationValidationError is the validation error returned by
// CharLocation.Validate if the designated constraints aren't met.
type CharLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CharLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CharLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CharLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CharLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CharLocationValidationError) ErrorName() string { return "CharLocationValidationError" }

// Error satisfies the builtin error interface
func (e CharLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCharLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CharLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CharLocationValidationError{}

// Validate checks the field values on ConnectorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorSpecMultiError, or
// nil if none found.
func (m *ConnectorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Driver

	// no validation rules for Properties

	// no validation rules for PropertiesFromVariables

	if len(errors) > 0 {
		return ConnectorSpecMultiError(errors)
	}

	return nil
}

// ConnectorSpecMultiError is an error wrapping multiple validation errors
// returned by ConnectorSpec.ValidateAll() if the designated constraints
// aren't met.
type ConnectorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorSpecMultiError) AllErrors() []error { return m }

// ConnectorSpecValidationError is the validation error returned by
// ConnectorSpec.Validate if the designated constraints aren't met.
type ConnectorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorSpecValidationError) ErrorName() string { return "ConnectorSpecValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorSpecValidationError{}

// Validate checks the field values on ConnectorState with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorState with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorStateMultiError,
// or nil if none found.
func (m *ConnectorState) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpecHash

	if len(errors) > 0 {
		return ConnectorStateMultiError(errors)
	}

	return nil
}

// ConnectorStateMultiError is an error wrapping multiple validation errors
// returned by ConnectorState.ValidateAll() if the designated constraints
// aren't met.
type ConnectorStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorStateMultiError) AllErrors() []error { return m }

// ConnectorStateValidationError is the validation error returned by
// ConnectorState.Validate if the designated constraints aren't met.
type ConnectorStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorStateValidationError) ErrorName() string { return "ConnectorStateValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorStateValidationError{}

// Validate checks the field values on ConnectorV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConnectorV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectorV2 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorV2MultiError, or
// nil if none found.
func (m *ConnectorV2) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectorV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorV2ValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectorV2ValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectorV2ValidationError{
				field:  "State",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConnectorV2MultiError(errors)
	}

	return nil
}

// ConnectorV2MultiError is an error wrapping multiple validation errors
// returned by ConnectorV2.ValidateAll() if the designated constraints aren't met.
type ConnectorV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorV2MultiError) AllErrors() []error { return m }

// ConnectorV2ValidationError is the validation error returned by
// ConnectorV2.Validate if the designated constraints aren't met.
type ConnectorV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorV2ValidationError) ErrorName() string { return "ConnectorV2ValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectorV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorV2ValidationError{}

// Validate checks the field values on MetricsViewSpec_DimensionV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_DimensionV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_DimensionV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_DimensionV2MultiError, or nil if none found.
func (m *MetricsViewSpec_DimensionV2) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_DimensionV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Column

	// no validation rules for Expression

	// no validation rules for Label

	// no validation rules for Description

	// no validation rules for Unnest

	if len(errors) > 0 {
		return MetricsViewSpec_DimensionV2MultiError(errors)
	}

	return nil
}

// MetricsViewSpec_DimensionV2MultiError is an error wrapping multiple
// validation errors returned by MetricsViewSpec_DimensionV2.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewSpec_DimensionV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_DimensionV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_DimensionV2MultiError) AllErrors() []error { return m }

// MetricsViewSpec_DimensionV2ValidationError is the validation error returned
// by MetricsViewSpec_DimensionV2.Validate if the designated constraints
// aren't met.
type MetricsViewSpec_DimensionV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_DimensionV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_DimensionV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_DimensionV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_DimensionV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_DimensionV2ValidationError) ErrorName() string {
	return "MetricsViewSpec_DimensionV2ValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_DimensionV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_DimensionV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_DimensionV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_DimensionV2ValidationError{}

// Validate checks the field values on MetricsViewSpec_DimensionSelector with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetricsViewSpec_DimensionSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_DimensionSelector
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_DimensionSelectorMultiError, or nil if none found.
func (m *MetricsViewSpec_DimensionSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_DimensionSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for TimeGrain

	// no validation rules for Desc

	if len(errors) > 0 {
		return MetricsViewSpec_DimensionSelectorMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_DimensionSelectorMultiError is an error wrapping multiple
// validation errors returned by
// MetricsViewSpec_DimensionSelector.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_DimensionSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_DimensionSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_DimensionSelectorMultiError) AllErrors() []error { return m }

// MetricsViewSpec_DimensionSelectorValidationError is the validation error
// returned by MetricsViewSpec_DimensionSelector.Validate if the designated
// constraints aren't met.
type MetricsViewSpec_DimensionSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_DimensionSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_DimensionSelectorValidationError) ErrorName() string {
	return "MetricsViewSpec_DimensionSelectorValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_DimensionSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_DimensionSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_DimensionSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_DimensionSelectorValidationError{}

// Validate checks the field values on MetricsViewSpec_MeasureWindow with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_MeasureWindow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_MeasureWindow with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_MeasureWindowMultiError, or nil if none found.
func (m *MetricsViewSpec_MeasureWindow) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_MeasureWindow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	for idx, item := range m.GetOrderBy() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureWindowValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureWindowValidationError{
						field:  fmt.Sprintf("OrderBy[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureWindowValidationError{
					field:  fmt.Sprintf("OrderBy[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for FrameExpression

	if len(errors) > 0 {
		return MetricsViewSpec_MeasureWindowMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_MeasureWindowMultiError is an error wrapping multiple
// validation errors returned by MetricsViewSpec_MeasureWindow.ValidateAll()
// if the designated constraints aren't met.
type MetricsViewSpec_MeasureWindowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_MeasureWindowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_MeasureWindowMultiError) AllErrors() []error { return m }

// MetricsViewSpec_MeasureWindowValidationError is the validation error
// returned by MetricsViewSpec_MeasureWindow.Validate if the designated
// constraints aren't met.
type MetricsViewSpec_MeasureWindowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_MeasureWindowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_MeasureWindowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_MeasureWindowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_MeasureWindowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_MeasureWindowValidationError) ErrorName() string {
	return "MetricsViewSpec_MeasureWindowValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_MeasureWindowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_MeasureWindow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_MeasureWindowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_MeasureWindowValidationError{}

// Validate checks the field values on MetricsViewSpec_MeasureV2 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_MeasureV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_MeasureV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_MeasureV2MultiError, or nil if none found.
func (m *MetricsViewSpec_MeasureV2) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_MeasureV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Expression

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetWindow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
					field:  "Window",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWindow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_MeasureV2ValidationError{
				field:  "Window",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPerDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
						field:  fmt.Sprintf("PerDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
						field:  fmt.Sprintf("PerDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureV2ValidationError{
					field:  fmt.Sprintf("PerDimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRequiredDimensions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
						field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_MeasureV2ValidationError{
						field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_MeasureV2ValidationError{
					field:  fmt.Sprintf("RequiredDimensions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Label

	// no validation rules for Description

	// no validation rules for FormatPreset

	// no validation rules for FormatD3

	// no validation rules for ValidPercentOfTotal

	if len(errors) > 0 {
		return MetricsViewSpec_MeasureV2MultiError(errors)
	}

	return nil
}

// MetricsViewSpec_MeasureV2MultiError is an error wrapping multiple validation
// errors returned by MetricsViewSpec_MeasureV2.ValidateAll() if the
// designated constraints aren't met.
type MetricsViewSpec_MeasureV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_MeasureV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_MeasureV2MultiError) AllErrors() []error { return m }

// MetricsViewSpec_MeasureV2ValidationError is the validation error returned by
// MetricsViewSpec_MeasureV2.Validate if the designated constraints aren't met.
type MetricsViewSpec_MeasureV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_MeasureV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_MeasureV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_MeasureV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_MeasureV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_MeasureV2ValidationError) ErrorName() string {
	return "MetricsViewSpec_MeasureV2ValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_MeasureV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_MeasureV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_MeasureV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_MeasureV2ValidationError{}

// Validate checks the field values on MetricsViewSpec_SecurityV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_SecurityV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_SecurityV2 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_SecurityV2MultiError, or nil if none found.
func (m *MetricsViewSpec_SecurityV2) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_SecurityV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Access

	// no validation rules for RowFilter

	if all {
		switch v := interface{}(m.GetQueryFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
					field:  "QueryFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
					field:  "QueryFilter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueryFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetricsViewSpec_SecurityV2ValidationError{
				field:  "QueryFilter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInclude() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
						field:  fmt.Sprintf("Include[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_SecurityV2ValidationError{
					field:  fmt.Sprintf("Include[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetExclude() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
						field:  fmt.Sprintf("Exclude[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_SecurityV2ValidationError{
						field:  fmt.Sprintf("Exclude[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_SecurityV2ValidationError{
					field:  fmt.Sprintf("Exclude[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewSpec_SecurityV2MultiError(errors)
	}

	return nil
}

// MetricsViewSpec_SecurityV2MultiError is an error wrapping multiple
// validation errors returned by MetricsViewSpec_SecurityV2.ValidateAll() if
// the designated constraints aren't met.
type MetricsViewSpec_SecurityV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_SecurityV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_SecurityV2MultiError) AllErrors() []error { return m }

// MetricsViewSpec_SecurityV2ValidationError is the validation error returned
// by MetricsViewSpec_SecurityV2.Validate if the designated constraints aren't met.
type MetricsViewSpec_SecurityV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_SecurityV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_SecurityV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_SecurityV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_SecurityV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_SecurityV2ValidationError) ErrorName() string {
	return "MetricsViewSpec_SecurityV2ValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_SecurityV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_SecurityV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_SecurityV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_SecurityV2ValidationError{}

// Validate checks the field values on
// MetricsViewSpec_AvailableComparisonOffset with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_AvailableComparisonOffset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewSpec_AvailableComparisonOffset with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MetricsViewSpec_AvailableComparisonOffsetMultiError, or nil if none found.
func (m *MetricsViewSpec_AvailableComparisonOffset) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_AvailableComparisonOffset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Offset

	// no validation rules for Range

	if len(errors) > 0 {
		return MetricsViewSpec_AvailableComparisonOffsetMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_AvailableComparisonOffsetMultiError is an error wrapping
// multiple validation errors returned by
// MetricsViewSpec_AvailableComparisonOffset.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_AvailableComparisonOffsetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_AvailableComparisonOffsetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_AvailableComparisonOffsetMultiError) AllErrors() []error { return m }

// MetricsViewSpec_AvailableComparisonOffsetValidationError is the validation
// error returned by MetricsViewSpec_AvailableComparisonOffset.Validate if the
// designated constraints aren't met.
type MetricsViewSpec_AvailableComparisonOffsetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) ErrorName() string {
	return "MetricsViewSpec_AvailableComparisonOffsetValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_AvailableComparisonOffsetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_AvailableComparisonOffset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_AvailableComparisonOffsetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_AvailableComparisonOffsetValidationError{}

// Validate checks the field values on MetricsViewSpec_AvailableTimeRange with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetricsViewSpec_AvailableTimeRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsViewSpec_AvailableTimeRange
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MetricsViewSpec_AvailableTimeRangeMultiError, or nil if none found.
func (m *MetricsViewSpec_AvailableTimeRange) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_AvailableTimeRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Range

	for idx, item := range m.GetComparisonOffsets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetricsViewSpec_AvailableTimeRangeValidationError{
						field:  fmt.Sprintf("ComparisonOffsets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetricsViewSpec_AvailableTimeRangeValidationError{
						field:  fmt.Sprintf("ComparisonOffsets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetricsViewSpec_AvailableTimeRangeValidationError{
					field:  fmt.Sprintf("ComparisonOffsets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetricsViewSpec_AvailableTimeRangeMultiError(errors)
	}

	return nil
}

// MetricsViewSpec_AvailableTimeRangeMultiError is an error wrapping multiple
// validation errors returned by
// MetricsViewSpec_AvailableTimeRange.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_AvailableTimeRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_AvailableTimeRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_AvailableTimeRangeMultiError) AllErrors() []error { return m }

// MetricsViewSpec_AvailableTimeRangeValidationError is the validation error
// returned by MetricsViewSpec_AvailableTimeRange.Validate if the designated
// constraints aren't met.
type MetricsViewSpec_AvailableTimeRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_AvailableTimeRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_AvailableTimeRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_AvailableTimeRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_AvailableTimeRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_AvailableTimeRangeValidationError) ErrorName() string {
	return "MetricsViewSpec_AvailableTimeRangeValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_AvailableTimeRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_AvailableTimeRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_AvailableTimeRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_AvailableTimeRangeValidationError{}

// Validate checks the field values on
// MetricsViewSpec_SecurityV2_FieldConditionV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsViewSpec_SecurityV2_FieldConditionV2) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetricsViewSpec_SecurityV2_FieldConditionV2 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MetricsViewSpec_SecurityV2_FieldConditionV2MultiError, or nil if none found.
func (m *MetricsViewSpec_SecurityV2_FieldConditionV2) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsViewSpec_SecurityV2_FieldConditionV2) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Condition

	if len(errors) > 0 {
		return MetricsViewSpec_SecurityV2_FieldConditionV2MultiError(errors)
	}

	return nil
}

// MetricsViewSpec_SecurityV2_FieldConditionV2MultiError is an error wrapping
// multiple validation errors returned by
// MetricsViewSpec_SecurityV2_FieldConditionV2.ValidateAll() if the designated
// constraints aren't met.
type MetricsViewSpec_SecurityV2_FieldConditionV2MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsViewSpec_SecurityV2_FieldConditionV2MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsViewSpec_SecurityV2_FieldConditionV2MultiError) AllErrors() []error { return m }

// MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError is the validation
// error returned by MetricsViewSpec_SecurityV2_FieldConditionV2.Validate if
// the designated constraints aren't met.
type MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) ErrorName() string {
	return "MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError"
}

// Error satisfies the builtin error interface
func (e MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsViewSpec_SecurityV2_FieldConditionV2.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsViewSpec_SecurityV2_FieldConditionV2ValidationError{}
