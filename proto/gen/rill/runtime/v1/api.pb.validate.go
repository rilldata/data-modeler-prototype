// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: rill/runtime/v1/api.proto

package runtimev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingRequestMultiError, or
// nil if none found.
func (m *PingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PingRequestMultiError(errors)
	}

	return nil
}

// PingRequestMultiError is an error wrapping multiple validation errors
// returned by PingRequest.ValidateAll() if the designated constraints aren't met.
type PingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingRequestMultiError) AllErrors() []error { return m }

// PingRequestValidationError is the validation error returned by
// PingRequest.Validate if the designated constraints aren't met.
type PingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingRequestValidationError) ErrorName() string { return "PingRequestValidationError" }

// Error satisfies the builtin error interface
func (e PingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingRequestValidationError{}

// Validate checks the field values on PingResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingResponseMultiError, or
// nil if none found.
func (m *PingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PingResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PingResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PingResponseValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PingResponseMultiError(errors)
	}

	return nil
}

// PingResponseMultiError is an error wrapping multiple validation errors
// returned by PingResponse.ValidateAll() if the designated constraints aren't met.
type PingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingResponseMultiError) AllErrors() []error { return m }

// PingResponseValidationError is the validation error returned by
// PingResponse.Validate if the designated constraints aren't met.
type PingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingResponseValidationError) ErrorName() string { return "PingResponseValidationError" }

// Error satisfies the builtin error interface
func (e PingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingResponseValidationError{}

// Validate checks the field values on Instance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstanceMultiError, or nil
// if none found.
func (m *Instance) ValidateAll() error {
	return m.validate(true)
}

func (m *Instance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_Instance_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := InstanceValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _Instance_OlapDriver_InLookup[m.GetOlapDriver()]; !ok {
		err := InstanceValidationError{
			field:  "OlapDriver",
			reason: "value must be in list [duckdb druid motherduck]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OlapDsn

	if _, ok := _Instance_RepoDriver_InLookup[m.GetRepoDriver()]; !ok {
		err := InstanceValidationError{
			field:  "RepoDriver",
			reason: "value must be in list [file metastore github]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RepoDsn

	// no validation rules for EmbedCatalog

	// no validation rules for Variables

	// no validation rules for ProjectVariables

	// no validation rules for IngestionLimitBytes

	if len(errors) > 0 {
		return InstanceMultiError(errors)
	}

	return nil
}

// InstanceMultiError is an error wrapping multiple validation errors returned
// by Instance.ValidateAll() if the designated constraints aren't met.
type InstanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstanceMultiError) AllErrors() []error { return m }

// InstanceValidationError is the validation error returned by
// Instance.Validate if the designated constraints aren't met.
type InstanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstanceValidationError) ErrorName() string { return "InstanceValidationError" }

// Error satisfies the builtin error interface
func (e InstanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstanceValidationError{}

var _Instance_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

var _Instance_OlapDriver_InLookup = map[string]struct{}{
	"duckdb":     {},
	"druid":      {},
	"motherduck": {},
}

var _Instance_RepoDriver_InLookup = map[string]struct{}{
	"file":      {},
	"metastore": {},
	"github":    {},
}

// Validate checks the field values on ListInstancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInstancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInstancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInstancesRequestMultiError, or nil if none found.
func (m *ListInstancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInstancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageSize

	// no validation rules for PageToken

	if len(errors) > 0 {
		return ListInstancesRequestMultiError(errors)
	}

	return nil
}

// ListInstancesRequestMultiError is an error wrapping multiple validation
// errors returned by ListInstancesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListInstancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInstancesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInstancesRequestMultiError) AllErrors() []error { return m }

// ListInstancesRequestValidationError is the validation error returned by
// ListInstancesRequest.Validate if the designated constraints aren't met.
type ListInstancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInstancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInstancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInstancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInstancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInstancesRequestValidationError) ErrorName() string {
	return "ListInstancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInstancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInstancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInstancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInstancesRequestValidationError{}

// Validate checks the field values on ListInstancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListInstancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListInstancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListInstancesResponseMultiError, or nil if none found.
func (m *ListInstancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListInstancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstances() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListInstancesResponseValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListInstancesResponseValidationError{
						field:  fmt.Sprintf("Instances[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListInstancesResponseValidationError{
					field:  fmt.Sprintf("Instances[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListInstancesResponseMultiError(errors)
	}

	return nil
}

// ListInstancesResponseMultiError is an error wrapping multiple validation
// errors returned by ListInstancesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListInstancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInstancesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInstancesResponseMultiError) AllErrors() []error { return m }

// ListInstancesResponseValidationError is the validation error returned by
// ListInstancesResponse.Validate if the designated constraints aren't met.
type ListInstancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInstancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInstancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInstancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInstancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInstancesResponseValidationError) ErrorName() string {
	return "ListInstancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListInstancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInstancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInstancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInstancesResponseValidationError{}

// Validate checks the field values on GetInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceRequestMultiError, or nil if none found.
func (m *GetInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GetInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetInstanceRequestMultiError(errors)
	}

	return nil
}

// GetInstanceRequestMultiError is an error wrapping multiple validation errors
// returned by GetInstanceRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceRequestMultiError) AllErrors() []error { return m }

// GetInstanceRequestValidationError is the validation error returned by
// GetInstanceRequest.Validate if the designated constraints aren't met.
type GetInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceRequestValidationError) ErrorName() string {
	return "GetInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceRequestValidationError{}

var _GetInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GetInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstanceResponseMultiError, or nil if none found.
func (m *GetInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInstanceResponseMultiError(errors)
	}

	return nil
}

// GetInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by GetInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstanceResponseMultiError) AllErrors() []error { return m }

// GetInstanceResponseValidationError is the validation error returned by
// GetInstanceResponse.Validate if the designated constraints aren't met.
type GetInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstanceResponseValidationError) ErrorName() string {
	return "GetInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstanceResponseValidationError{}

// Validate checks the field values on CreateInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInstanceRequestMultiError, or nil if none found.
func (m *CreateInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetInstanceId() != "" {

		if !_CreateInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
			err := CreateInstanceRequestValidationError{
				field:  "InstanceId",
				reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if _, ok := _CreateInstanceRequest_OlapDriver_InLookup[m.GetOlapDriver()]; !ok {
		err := CreateInstanceRequestValidationError{
			field:  "OlapDriver",
			reason: "value must be in list [duckdb druid motherduck]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OlapDsn

	if _, ok := _CreateInstanceRequest_RepoDriver_InLookup[m.GetRepoDriver()]; !ok {
		err := CreateInstanceRequestValidationError{
			field:  "RepoDriver",
			reason: "value must be in list [file metastore github]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RepoDsn

	// no validation rules for EmbedCatalog

	// no validation rules for Variables

	// no validation rules for IngestionLimitBytes

	if len(errors) > 0 {
		return CreateInstanceRequestMultiError(errors)
	}

	return nil
}

// CreateInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInstanceRequestMultiError) AllErrors() []error { return m }

// CreateInstanceRequestValidationError is the validation error returned by
// CreateInstanceRequest.Validate if the designated constraints aren't met.
type CreateInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInstanceRequestValidationError) ErrorName() string {
	return "CreateInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInstanceRequestValidationError{}

var _CreateInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

var _CreateInstanceRequest_OlapDriver_InLookup = map[string]struct{}{
	"duckdb":     {},
	"druid":      {},
	"motherduck": {},
}

var _CreateInstanceRequest_RepoDriver_InLookup = map[string]struct{}{
	"file":      {},
	"metastore": {},
	"github":    {},
}

// Validate checks the field values on CreateInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInstanceResponseMultiError, or nil if none found.
func (m *CreateInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInstanceResponseMultiError(errors)
	}

	return nil
}

// CreateInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInstanceResponseMultiError) AllErrors() []error { return m }

// CreateInstanceResponseValidationError is the validation error returned by
// CreateInstanceResponse.Validate if the designated constraints aren't met.
type CreateInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInstanceResponseValidationError) ErrorName() string {
	return "CreateInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInstanceResponseValidationError{}

// Validate checks the field values on DeleteInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteInstanceRequestMultiError, or nil if none found.
func (m *DeleteInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := DeleteInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DropDb

	if len(errors) > 0 {
		return DeleteInstanceRequestMultiError(errors)
	}

	return nil
}

// DeleteInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteInstanceRequestMultiError) AllErrors() []error { return m }

// DeleteInstanceRequestValidationError is the validation error returned by
// DeleteInstanceRequest.Validate if the designated constraints aren't met.
type DeleteInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInstanceRequestValidationError) ErrorName() string {
	return "DeleteInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInstanceRequestValidationError{}

var _DeleteInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on DeleteInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteInstanceResponseMultiError, or nil if none found.
func (m *DeleteInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteInstanceResponseMultiError(errors)
	}

	return nil
}

// DeleteInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteInstanceResponseMultiError) AllErrors() []error { return m }

// DeleteInstanceResponseValidationError is the validation error returned by
// DeleteInstanceResponse.Validate if the designated constraints aren't met.
type DeleteInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInstanceResponseValidationError) ErrorName() string {
	return "DeleteInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInstanceResponseValidationError{}

// Validate checks the field values on EditInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditInstanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditInstanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditInstanceRequestMultiError, or nil if none found.
func (m *EditInstanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EditInstanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_EditInstanceRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := EditInstanceRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _EditInstanceRequest_OlapDriver_InLookup[m.GetOlapDriver()]; !ok {
		err := EditInstanceRequestValidationError{
			field:  "OlapDriver",
			reason: "value must be in list [duckdb druid motherduck]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OlapDsn

	if _, ok := _EditInstanceRequest_RepoDriver_InLookup[m.GetRepoDriver()]; !ok {
		err := EditInstanceRequestValidationError{
			field:  "RepoDriver",
			reason: "value must be in list [file metastore github]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RepoDsn

	// no validation rules for EmbedCatalog

	// no validation rules for Variables

	// no validation rules for IngestionLimitBytes

	if len(errors) > 0 {
		return EditInstanceRequestMultiError(errors)
	}

	return nil
}

// EditInstanceRequestMultiError is an error wrapping multiple validation
// errors returned by EditInstanceRequest.ValidateAll() if the designated
// constraints aren't met.
type EditInstanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditInstanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditInstanceRequestMultiError) AllErrors() []error { return m }

// EditInstanceRequestValidationError is the validation error returned by
// EditInstanceRequest.Validate if the designated constraints aren't met.
type EditInstanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditInstanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditInstanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditInstanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditInstanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditInstanceRequestValidationError) ErrorName() string {
	return "EditInstanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EditInstanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditInstanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditInstanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditInstanceRequestValidationError{}

var _EditInstanceRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

var _EditInstanceRequest_OlapDriver_InLookup = map[string]struct{}{
	"duckdb":     {},
	"druid":      {},
	"motherduck": {},
}

var _EditInstanceRequest_RepoDriver_InLookup = map[string]struct{}{
	"file":      {},
	"metastore": {},
	"github":    {},
}

// Validate checks the field values on EditInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditInstanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditInstanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditInstanceResponseMultiError, or nil if none found.
func (m *EditInstanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EditInstanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EditInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EditInstanceResponseValidationError{
					field:  "Instance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EditInstanceResponseValidationError{
				field:  "Instance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EditInstanceResponseMultiError(errors)
	}

	return nil
}

// EditInstanceResponseMultiError is an error wrapping multiple validation
// errors returned by EditInstanceResponse.ValidateAll() if the designated
// constraints aren't met.
type EditInstanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditInstanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditInstanceResponseMultiError) AllErrors() []error { return m }

// EditInstanceResponseValidationError is the validation error returned by
// EditInstanceResponse.Validate if the designated constraints aren't met.
type EditInstanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditInstanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditInstanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditInstanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditInstanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditInstanceResponseValidationError) ErrorName() string {
	return "EditInstanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EditInstanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditInstanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditInstanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditInstanceResponseValidationError{}

// Validate checks the field values on ListFilesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFilesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFilesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFilesRequestMultiError, or nil if none found.
func (m *ListFilesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFilesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListFilesRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := ListFilesRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Glob

	if len(errors) > 0 {
		return ListFilesRequestMultiError(errors)
	}

	return nil
}

// ListFilesRequestMultiError is an error wrapping multiple validation errors
// returned by ListFilesRequest.ValidateAll() if the designated constraints
// aren't met.
type ListFilesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFilesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFilesRequestMultiError) AllErrors() []error { return m }

// ListFilesRequestValidationError is the validation error returned by
// ListFilesRequest.Validate if the designated constraints aren't met.
type ListFilesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFilesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFilesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFilesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFilesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFilesRequestValidationError) ErrorName() string { return "ListFilesRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListFilesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFilesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFilesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFilesRequestValidationError{}

var _ListFilesRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on ListFilesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFilesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFilesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFilesResponseMultiError, or nil if none found.
func (m *ListFilesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFilesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListFilesResponseMultiError(errors)
	}

	return nil
}

// ListFilesResponseMultiError is an error wrapping multiple validation errors
// returned by ListFilesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListFilesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFilesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFilesResponseMultiError) AllErrors() []error { return m }

// ListFilesResponseValidationError is the validation error returned by
// ListFilesResponse.Validate if the designated constraints aren't met.
type ListFilesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFilesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFilesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFilesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFilesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFilesResponseValidationError) ErrorName() string {
	return "ListFilesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFilesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFilesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFilesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFilesResponseValidationError{}

// Validate checks the field values on GetFileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetFileRequestMultiError,
// or nil if none found.
func (m *GetFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GetFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := GetFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFileRequestMultiError(errors)
	}

	return nil
}

// GetFileRequestMultiError is an error wrapping multiple validation errors
// returned by GetFileRequest.ValidateAll() if the designated constraints
// aren't met.
type GetFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileRequestMultiError) AllErrors() []error { return m }

// GetFileRequestValidationError is the validation error returned by
// GetFileRequest.Validate if the designated constraints aren't met.
type GetFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileRequestValidationError) ErrorName() string { return "GetFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileRequestValidationError{}

var _GetFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GetFileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileResponseMultiError, or nil if none found.
func (m *GetFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Blob

	if all {
		switch v := interface{}(m.GetUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFileResponseValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFileResponseValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFileResponseValidationError{
				field:  "UpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFileResponseMultiError(errors)
	}

	return nil
}

// GetFileResponseMultiError is an error wrapping multiple validation errors
// returned by GetFileResponse.ValidateAll() if the designated constraints
// aren't met.
type GetFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileResponseMultiError) AllErrors() []error { return m }

// GetFileResponseValidationError is the validation error returned by
// GetFileResponse.Validate if the designated constraints aren't met.
type GetFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileResponseValidationError) ErrorName() string { return "GetFileResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileResponseValidationError{}

// Validate checks the field values on PutFileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutFileRequestMultiError,
// or nil if none found.
func (m *PutFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_PutFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := PutFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := PutFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Blob

	// no validation rules for Create

	// no validation rules for CreateOnly

	if len(errors) > 0 {
		return PutFileRequestMultiError(errors)
	}

	return nil
}

// PutFileRequestMultiError is an error wrapping multiple validation errors
// returned by PutFileRequest.ValidateAll() if the designated constraints
// aren't met.
type PutFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileRequestMultiError) AllErrors() []error { return m }

// PutFileRequestValidationError is the validation error returned by
// PutFileRequest.Validate if the designated constraints aren't met.
type PutFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileRequestValidationError) ErrorName() string { return "PutFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileRequestValidationError{}

var _PutFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on PutFileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutFileResponseMultiError, or nil if none found.
func (m *PutFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FilePath

	if len(errors) > 0 {
		return PutFileResponseMultiError(errors)
	}

	return nil
}

// PutFileResponseMultiError is an error wrapping multiple validation errors
// returned by PutFileResponse.ValidateAll() if the designated constraints
// aren't met.
type PutFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileResponseMultiError) AllErrors() []error { return m }

// PutFileResponseValidationError is the validation error returned by
// PutFileResponse.Validate if the designated constraints aren't met.
type PutFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileResponseValidationError) ErrorName() string { return "PutFileResponseValidationError" }

// Error satisfies the builtin error interface
func (e PutFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileResponseValidationError{}

// Validate checks the field values on DeleteFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileRequestMultiError, or nil if none found.
func (m *DeleteFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := DeleteFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := DeleteFileRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteFileRequestMultiError(errors)
	}

	return nil
}

// DeleteFileRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteFileRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileRequestMultiError) AllErrors() []error { return m }

// DeleteFileRequestValidationError is the validation error returned by
// DeleteFileRequest.Validate if the designated constraints aren't met.
type DeleteFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileRequestValidationError) ErrorName() string {
	return "DeleteFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileRequestValidationError{}

var _DeleteFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on DeleteFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteFileResponseMultiError, or nil if none found.
func (m *DeleteFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteFileResponseMultiError(errors)
	}

	return nil
}

// DeleteFileResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteFileResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileResponseMultiError) AllErrors() []error { return m }

// DeleteFileResponseValidationError is the validation error returned by
// DeleteFileResponse.Validate if the designated constraints aren't met.
type DeleteFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileResponseValidationError) ErrorName() string {
	return "DeleteFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileResponseValidationError{}

// Validate checks the field values on RenameFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RenameFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenameFileRequestMultiError, or nil if none found.
func (m *RenameFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RenameFileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := RenameFileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetFromPath()) < 1 {
		err := RenameFileRequestValidationError{
			field:  "FromPath",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetToPath()) < 1 {
		err := RenameFileRequestValidationError{
			field:  "ToPath",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RenameFileRequestMultiError(errors)
	}

	return nil
}

// RenameFileRequestMultiError is an error wrapping multiple validation errors
// returned by RenameFileRequest.ValidateAll() if the designated constraints
// aren't met.
type RenameFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileRequestMultiError) AllErrors() []error { return m }

// RenameFileRequestValidationError is the validation error returned by
// RenameFileRequest.Validate if the designated constraints aren't met.
type RenameFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileRequestValidationError) ErrorName() string {
	return "RenameFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileRequestValidationError{}

var _RenameFileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on RenameFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenameFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenameFileResponseMultiError, or nil if none found.
func (m *RenameFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RenameFileResponseMultiError(errors)
	}

	return nil
}

// RenameFileResponseMultiError is an error wrapping multiple validation errors
// returned by RenameFileResponse.ValidateAll() if the designated constraints
// aren't met.
type RenameFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileResponseMultiError) AllErrors() []error { return m }

// RenameFileResponseValidationError is the validation error returned by
// RenameFileResponse.Validate if the designated constraints aren't met.
type RenameFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileResponseValidationError) ErrorName() string {
	return "RenameFileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileResponseValidationError{}

// Validate checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Example) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Example with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ExampleMultiError, or nil if none found.
func (m *Example) ValidateAll() error {
	return m.validate(true)
}

func (m *Example) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Title

	// no validation rules for Description

	if len(errors) > 0 {
		return ExampleMultiError(errors)
	}

	return nil
}

// ExampleMultiError is an error wrapping multiple validation errors returned
// by Example.ValidateAll() if the designated constraints aren't met.
type ExampleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExampleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExampleMultiError) AllErrors() []error { return m }

// ExampleValidationError is the validation error returned by Example.Validate
// if the designated constraints aren't met.
type ExampleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExampleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExampleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExampleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExampleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExampleValidationError) ErrorName() string { return "ExampleValidationError" }

// Error satisfies the builtin error interface
func (e ExampleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExample.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExampleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExampleValidationError{}

// Validate checks the field values on ListExamplesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamplesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamplesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamplesRequestMultiError, or nil if none found.
func (m *ListExamplesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamplesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListExamplesRequestMultiError(errors)
	}

	return nil
}

// ListExamplesRequestMultiError is an error wrapping multiple validation
// errors returned by ListExamplesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListExamplesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamplesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamplesRequestMultiError) AllErrors() []error { return m }

// ListExamplesRequestValidationError is the validation error returned by
// ListExamplesRequest.Validate if the designated constraints aren't met.
type ListExamplesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamplesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamplesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamplesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamplesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamplesRequestValidationError) ErrorName() string {
	return "ListExamplesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamplesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamplesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamplesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamplesRequestValidationError{}

// Validate checks the field values on ListExamplesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListExamplesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListExamplesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListExamplesResponseMultiError, or nil if none found.
func (m *ListExamplesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListExamplesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExamples() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListExamplesResponseValidationError{
						field:  fmt.Sprintf("Examples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListExamplesResponseValidationError{
						field:  fmt.Sprintf("Examples[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListExamplesResponseValidationError{
					field:  fmt.Sprintf("Examples[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListExamplesResponseMultiError(errors)
	}

	return nil
}

// ListExamplesResponseMultiError is an error wrapping multiple validation
// errors returned by ListExamplesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListExamplesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListExamplesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListExamplesResponseMultiError) AllErrors() []error { return m }

// ListExamplesResponseValidationError is the validation error returned by
// ListExamplesResponse.Validate if the designated constraints aren't met.
type ListExamplesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListExamplesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListExamplesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListExamplesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListExamplesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListExamplesResponseValidationError) ErrorName() string {
	return "ListExamplesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListExamplesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListExamplesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListExamplesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListExamplesResponseValidationError{}

// Validate checks the field values on UnpackExampleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackExampleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackExampleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackExampleRequestMultiError, or nil if none found.
func (m *UnpackExampleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackExampleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UnpackExampleRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := UnpackExampleRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UnpackExampleRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return UnpackExampleRequestMultiError(errors)
	}

	return nil
}

// UnpackExampleRequestMultiError is an error wrapping multiple validation
// errors returned by UnpackExampleRequest.ValidateAll() if the designated
// constraints aren't met.
type UnpackExampleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackExampleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackExampleRequestMultiError) AllErrors() []error { return m }

// UnpackExampleRequestValidationError is the validation error returned by
// UnpackExampleRequest.Validate if the designated constraints aren't met.
type UnpackExampleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackExampleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackExampleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackExampleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackExampleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackExampleRequestValidationError) ErrorName() string {
	return "UnpackExampleRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackExampleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackExampleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackExampleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackExampleRequestValidationError{}

var _UnpackExampleRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on UnpackExampleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackExampleResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackExampleResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackExampleResponseMultiError, or nil if none found.
func (m *UnpackExampleResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackExampleResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UnpackExampleResponseMultiError(errors)
	}

	return nil
}

// UnpackExampleResponseMultiError is an error wrapping multiple validation
// errors returned by UnpackExampleResponse.ValidateAll() if the designated
// constraints aren't met.
type UnpackExampleResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackExampleResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackExampleResponseMultiError) AllErrors() []error { return m }

// UnpackExampleResponseValidationError is the validation error returned by
// UnpackExampleResponse.Validate if the designated constraints aren't met.
type UnpackExampleResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackExampleResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackExampleResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackExampleResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackExampleResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackExampleResponseValidationError) ErrorName() string {
	return "UnpackExampleResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackExampleResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackExampleResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackExampleResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackExampleResponseValidationError{}

// Validate checks the field values on UnpackEmptyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackEmptyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackEmptyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackEmptyRequestMultiError, or nil if none found.
func (m *UnpackEmptyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackEmptyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UnpackEmptyRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := UnpackEmptyRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Title

	// no validation rules for Force

	if len(errors) > 0 {
		return UnpackEmptyRequestMultiError(errors)
	}

	return nil
}

// UnpackEmptyRequestMultiError is an error wrapping multiple validation errors
// returned by UnpackEmptyRequest.ValidateAll() if the designated constraints
// aren't met.
type UnpackEmptyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackEmptyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackEmptyRequestMultiError) AllErrors() []error { return m }

// UnpackEmptyRequestValidationError is the validation error returned by
// UnpackEmptyRequest.Validate if the designated constraints aren't met.
type UnpackEmptyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackEmptyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackEmptyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackEmptyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackEmptyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackEmptyRequestValidationError) ErrorName() string {
	return "UnpackEmptyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackEmptyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackEmptyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackEmptyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackEmptyRequestValidationError{}

var _UnpackEmptyRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on UnpackEmptyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnpackEmptyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnpackEmptyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnpackEmptyResponseMultiError, or nil if none found.
func (m *UnpackEmptyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnpackEmptyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UnpackEmptyResponseMultiError(errors)
	}

	return nil
}

// UnpackEmptyResponseMultiError is an error wrapping multiple validation
// errors returned by UnpackEmptyResponse.ValidateAll() if the designated
// constraints aren't met.
type UnpackEmptyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnpackEmptyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnpackEmptyResponseMultiError) AllErrors() []error { return m }

// UnpackEmptyResponseValidationError is the validation error returned by
// UnpackEmptyResponse.Validate if the designated constraints aren't met.
type UnpackEmptyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnpackEmptyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnpackEmptyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnpackEmptyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnpackEmptyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnpackEmptyResponseValidationError) ErrorName() string {
	return "UnpackEmptyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnpackEmptyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnpackEmptyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnpackEmptyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnpackEmptyResponseValidationError{}

// Validate checks the field values on CatalogEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CatalogEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CatalogEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CatalogEntryMultiError, or
// nil if none found.
func (m *CatalogEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *CatalogEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Embedded

	if all {
		switch v := interface{}(m.GetCreatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "CreatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CatalogEntryValidationError{
				field:  "CreatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "UpdatedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CatalogEntryValidationError{
				field:  "UpdatedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefreshedOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CatalogEntryValidationError{
					field:  "RefreshedOn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshedOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CatalogEntryValidationError{
				field:  "RefreshedOn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Object.(type) {
	case *CatalogEntry_Table:
		if v == nil {
			err := CatalogEntryValidationError{
				field:  "Object",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTable()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Table",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Table",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTable()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogEntryValidationError{
					field:  "Table",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CatalogEntry_Source:
		if v == nil {
			err := CatalogEntryValidationError{
				field:  "Object",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSource()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Source",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogEntryValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CatalogEntry_Model:
		if v == nil {
			err := CatalogEntryValidationError{
				field:  "Object",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetModel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "Model",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetModel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogEntryValidationError{
					field:  "Model",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CatalogEntry_MetricsView:
		if v == nil {
			err := CatalogEntryValidationError{
				field:  "Object",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMetricsView()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CatalogEntryValidationError{
						field:  "MetricsView",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetricsView()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CatalogEntryValidationError{
					field:  "MetricsView",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CatalogEntryMultiError(errors)
	}

	return nil
}

// CatalogEntryMultiError is an error wrapping multiple validation errors
// returned by CatalogEntry.ValidateAll() if the designated constraints aren't met.
type CatalogEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CatalogEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CatalogEntryMultiError) AllErrors() []error { return m }

// CatalogEntryValidationError is the validation error returned by
// CatalogEntry.Validate if the designated constraints aren't met.
type CatalogEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CatalogEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CatalogEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CatalogEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CatalogEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CatalogEntryValidationError) ErrorName() string { return "CatalogEntryValidationError" }

// Error satisfies the builtin error interface
func (e CatalogEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCatalogEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CatalogEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CatalogEntryValidationError{}

// Validate checks the field values on ListCatalogEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogEntriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogEntriesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogEntriesRequestMultiError, or nil if none found.
func (m *ListCatalogEntriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogEntriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListCatalogEntriesRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := ListCatalogEntriesRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ObjectType_name[int32(m.GetType())]; !ok {
		err := ListCatalogEntriesRequestValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCatalogEntriesRequestMultiError(errors)
	}

	return nil
}

// ListCatalogEntriesRequestMultiError is an error wrapping multiple validation
// errors returned by ListCatalogEntriesRequest.ValidateAll() if the
// designated constraints aren't met.
type ListCatalogEntriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogEntriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogEntriesRequestMultiError) AllErrors() []error { return m }

// ListCatalogEntriesRequestValidationError is the validation error returned by
// ListCatalogEntriesRequest.Validate if the designated constraints aren't met.
type ListCatalogEntriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogEntriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogEntriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogEntriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogEntriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogEntriesRequestValidationError) ErrorName() string {
	return "ListCatalogEntriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogEntriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogEntriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogEntriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogEntriesRequestValidationError{}

var _ListCatalogEntriesRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on ListCatalogEntriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCatalogEntriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCatalogEntriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCatalogEntriesResponseMultiError, or nil if none found.
func (m *ListCatalogEntriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCatalogEntriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCatalogEntriesResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCatalogEntriesResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCatalogEntriesResponseValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCatalogEntriesResponseMultiError(errors)
	}

	return nil
}

// ListCatalogEntriesResponseMultiError is an error wrapping multiple
// validation errors returned by ListCatalogEntriesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListCatalogEntriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCatalogEntriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCatalogEntriesResponseMultiError) AllErrors() []error { return m }

// ListCatalogEntriesResponseValidationError is the validation error returned
// by ListCatalogEntriesResponse.Validate if the designated constraints aren't met.
type ListCatalogEntriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCatalogEntriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCatalogEntriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCatalogEntriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCatalogEntriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCatalogEntriesResponseValidationError) ErrorName() string {
	return "ListCatalogEntriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCatalogEntriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCatalogEntriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCatalogEntriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCatalogEntriesResponseValidationError{}

// Validate checks the field values on GetCatalogEntryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCatalogEntryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCatalogEntryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCatalogEntryRequestMultiError, or nil if none found.
func (m *GetCatalogEntryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCatalogEntryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetCatalogEntryRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := GetCatalogEntryRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return GetCatalogEntryRequestMultiError(errors)
	}

	return nil
}

// GetCatalogEntryRequestMultiError is an error wrapping multiple validation
// errors returned by GetCatalogEntryRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCatalogEntryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCatalogEntryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCatalogEntryRequestMultiError) AllErrors() []error { return m }

// GetCatalogEntryRequestValidationError is the validation error returned by
// GetCatalogEntryRequest.Validate if the designated constraints aren't met.
type GetCatalogEntryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCatalogEntryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCatalogEntryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCatalogEntryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCatalogEntryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCatalogEntryRequestValidationError) ErrorName() string {
	return "GetCatalogEntryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCatalogEntryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCatalogEntryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCatalogEntryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCatalogEntryRequestValidationError{}

var _GetCatalogEntryRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on GetCatalogEntryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCatalogEntryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCatalogEntryResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCatalogEntryResponseMultiError, or nil if none found.
func (m *GetCatalogEntryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCatalogEntryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntry()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCatalogEntryResponseValidationError{
					field:  "Entry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCatalogEntryResponseValidationError{
					field:  "Entry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntry()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCatalogEntryResponseValidationError{
				field:  "Entry",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCatalogEntryResponseMultiError(errors)
	}

	return nil
}

// GetCatalogEntryResponseMultiError is an error wrapping multiple validation
// errors returned by GetCatalogEntryResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCatalogEntryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCatalogEntryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCatalogEntryResponseMultiError) AllErrors() []error { return m }

// GetCatalogEntryResponseValidationError is the validation error returned by
// GetCatalogEntryResponse.Validate if the designated constraints aren't met.
type GetCatalogEntryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCatalogEntryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCatalogEntryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCatalogEntryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCatalogEntryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCatalogEntryResponseValidationError) ErrorName() string {
	return "GetCatalogEntryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCatalogEntryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCatalogEntryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCatalogEntryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCatalogEntryResponseValidationError{}

// Validate checks the field values on TriggerRefreshRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerRefreshRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerRefreshRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerRefreshRequestMultiError, or nil if none found.
func (m *TriggerRefreshRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerRefreshRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_TriggerRefreshRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := TriggerRefreshRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return TriggerRefreshRequestMultiError(errors)
	}

	return nil
}

// TriggerRefreshRequestMultiError is an error wrapping multiple validation
// errors returned by TriggerRefreshRequest.ValidateAll() if the designated
// constraints aren't met.
type TriggerRefreshRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerRefreshRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerRefreshRequestMultiError) AllErrors() []error { return m }

// TriggerRefreshRequestValidationError is the validation error returned by
// TriggerRefreshRequest.Validate if the designated constraints aren't met.
type TriggerRefreshRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerRefreshRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerRefreshRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerRefreshRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerRefreshRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerRefreshRequestValidationError) ErrorName() string {
	return "TriggerRefreshRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerRefreshRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerRefreshRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerRefreshRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerRefreshRequestValidationError{}

var _TriggerRefreshRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on TriggerRefreshResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerRefreshResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerRefreshResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerRefreshResponseMultiError, or nil if none found.
func (m *TriggerRefreshResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerRefreshResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TriggerRefreshResponseMultiError(errors)
	}

	return nil
}

// TriggerRefreshResponseMultiError is an error wrapping multiple validation
// errors returned by TriggerRefreshResponse.ValidateAll() if the designated
// constraints aren't met.
type TriggerRefreshResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerRefreshResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerRefreshResponseMultiError) AllErrors() []error { return m }

// TriggerRefreshResponseValidationError is the validation error returned by
// TriggerRefreshResponse.Validate if the designated constraints aren't met.
type TriggerRefreshResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerRefreshResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerRefreshResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerRefreshResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerRefreshResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerRefreshResponseValidationError) ErrorName() string {
	return "TriggerRefreshResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerRefreshResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerRefreshResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerRefreshResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerRefreshResponseValidationError{}

// Validate checks the field values on TriggerSyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerSyncRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerSyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerSyncRequestMultiError, or nil if none found.
func (m *TriggerSyncRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerSyncRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_TriggerSyncRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := TriggerSyncRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TriggerSyncRequestMultiError(errors)
	}

	return nil
}

// TriggerSyncRequestMultiError is an error wrapping multiple validation errors
// returned by TriggerSyncRequest.ValidateAll() if the designated constraints
// aren't met.
type TriggerSyncRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerSyncRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerSyncRequestMultiError) AllErrors() []error { return m }

// TriggerSyncRequestValidationError is the validation error returned by
// TriggerSyncRequest.Validate if the designated constraints aren't met.
type TriggerSyncRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerSyncRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerSyncRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerSyncRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerSyncRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerSyncRequestValidationError) ErrorName() string {
	return "TriggerSyncRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerSyncRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerSyncRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerSyncRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerSyncRequestValidationError{}

var _TriggerSyncRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on TriggerSyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TriggerSyncResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TriggerSyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TriggerSyncResponseMultiError, or nil if none found.
func (m *TriggerSyncResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TriggerSyncResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ObjectsCount

	// no validation rules for ObjectsAddedCount

	// no validation rules for ObjectsUpdatedCount

	// no validation rules for ObjectsRemovedCount

	if len(errors) > 0 {
		return TriggerSyncResponseMultiError(errors)
	}

	return nil
}

// TriggerSyncResponseMultiError is an error wrapping multiple validation
// errors returned by TriggerSyncResponse.ValidateAll() if the designated
// constraints aren't met.
type TriggerSyncResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerSyncResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerSyncResponseMultiError) AllErrors() []error { return m }

// TriggerSyncResponseValidationError is the validation error returned by
// TriggerSyncResponse.Validate if the designated constraints aren't met.
type TriggerSyncResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerSyncResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerSyncResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerSyncResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerSyncResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerSyncResponseValidationError) ErrorName() string {
	return "TriggerSyncResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TriggerSyncResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTriggerSyncResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerSyncResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerSyncResponseValidationError{}

// Validate checks the field values on ReconcileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReconcileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconcileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconcileRequestMultiError, or nil if none found.
func (m *ReconcileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconcileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ReconcileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := ReconcileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Dry

	// no validation rules for Strict

	if len(errors) > 0 {
		return ReconcileRequestMultiError(errors)
	}

	return nil
}

// ReconcileRequestMultiError is an error wrapping multiple validation errors
// returned by ReconcileRequest.ValidateAll() if the designated constraints
// aren't met.
type ReconcileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconcileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconcileRequestMultiError) AllErrors() []error { return m }

// ReconcileRequestValidationError is the validation error returned by
// ReconcileRequest.Validate if the designated constraints aren't met.
type ReconcileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconcileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconcileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconcileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconcileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconcileRequestValidationError) ErrorName() string { return "ReconcileRequestValidationError" }

// Error satisfies the builtin error interface
func (e ReconcileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconcileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconcileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconcileRequestValidationError{}

var _ReconcileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on ReconcileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReconcileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconcileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconcileResponseMultiError, or nil if none found.
func (m *ReconcileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconcileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReconcileResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReconcileResponseMultiError(errors)
	}

	return nil
}

// ReconcileResponseMultiError is an error wrapping multiple validation errors
// returned by ReconcileResponse.ValidateAll() if the designated constraints
// aren't met.
type ReconcileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconcileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconcileResponseMultiError) AllErrors() []error { return m }

// ReconcileResponseValidationError is the validation error returned by
// ReconcileResponse.Validate if the designated constraints aren't met.
type ReconcileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconcileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconcileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconcileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconcileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconcileResponseValidationError) ErrorName() string {
	return "ReconcileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReconcileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconcileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconcileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconcileResponseValidationError{}

// Validate checks the field values on ReconcileError with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ReconcileError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconcileError with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ReconcileErrorMultiError,
// or nil if none found.
func (m *ReconcileError) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconcileError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := ReconcileError_Code_name[int32(m.GetCode())]; !ok {
		err := ReconcileErrorValidationError{
			field:  "Code",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	// no validation rules for FilePath

	if all {
		switch v := interface{}(m.GetStartLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReconcileErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReconcileErrorValidationError{
					field:  "StartLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReconcileErrorValidationError{
				field:  "StartLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReconcileErrorValidationError{
					field:  "EndLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReconcileErrorValidationError{
					field:  "EndLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReconcileErrorValidationError{
				field:  "EndLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReconcileErrorMultiError(errors)
	}

	return nil
}

// ReconcileErrorMultiError is an error wrapping multiple validation errors
// returned by ReconcileError.ValidateAll() if the designated constraints
// aren't met.
type ReconcileErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconcileErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconcileErrorMultiError) AllErrors() []error { return m }

// ReconcileErrorValidationError is the validation error returned by
// ReconcileError.Validate if the designated constraints aren't met.
type ReconcileErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconcileErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconcileErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconcileErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconcileErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconcileErrorValidationError) ErrorName() string { return "ReconcileErrorValidationError" }

// Error satisfies the builtin error interface
func (e ReconcileErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconcileError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconcileErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconcileErrorValidationError{}

// Validate checks the field values on PutFileAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutFileAndReconcileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutFileAndReconcileRequestMultiError, or nil if none found.
func (m *PutFileAndReconcileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileAndReconcileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_PutFileAndReconcileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := PutFileAndReconcileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Path

	// no validation rules for Blob

	// no validation rules for Create

	// no validation rules for CreateOnly

	// no validation rules for Dry

	// no validation rules for Strict

	if len(errors) > 0 {
		return PutFileAndReconcileRequestMultiError(errors)
	}

	return nil
}

// PutFileAndReconcileRequestMultiError is an error wrapping multiple
// validation errors returned by PutFileAndReconcileRequest.ValidateAll() if
// the designated constraints aren't met.
type PutFileAndReconcileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileAndReconcileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileAndReconcileRequestMultiError) AllErrors() []error { return m }

// PutFileAndReconcileRequestValidationError is the validation error returned
// by PutFileAndReconcileRequest.Validate if the designated constraints aren't met.
type PutFileAndReconcileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileAndReconcileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileAndReconcileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileAndReconcileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileAndReconcileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileAndReconcileRequestValidationError) ErrorName() string {
	return "PutFileAndReconcileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PutFileAndReconcileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileAndReconcileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileAndReconcileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileAndReconcileRequestValidationError{}

var _PutFileAndReconcileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on PutFileAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PutFileAndReconcileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutFileAndReconcileResponseMultiError, or nil if none found.
func (m *PutFileAndReconcileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileAndReconcileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PutFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PutFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PutFileAndReconcileResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PutFileAndReconcileResponseMultiError(errors)
	}

	return nil
}

// PutFileAndReconcileResponseMultiError is an error wrapping multiple
// validation errors returned by PutFileAndReconcileResponse.ValidateAll() if
// the designated constraints aren't met.
type PutFileAndReconcileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileAndReconcileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileAndReconcileResponseMultiError) AllErrors() []error { return m }

// PutFileAndReconcileResponseValidationError is the validation error returned
// by PutFileAndReconcileResponse.Validate if the designated constraints
// aren't met.
type PutFileAndReconcileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileAndReconcileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileAndReconcileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileAndReconcileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileAndReconcileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileAndReconcileResponseValidationError) ErrorName() string {
	return "PutFileAndReconcileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PutFileAndReconcileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileAndReconcileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileAndReconcileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileAndReconcileResponseValidationError{}

// Validate checks the field values on DeleteFileAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileAndReconcileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileAndReconcileRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteFileAndReconcileRequestMultiError, or nil if none found.
func (m *DeleteFileAndReconcileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileAndReconcileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteFileAndReconcileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := DeleteFileAndReconcileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Path

	// no validation rules for Dry

	// no validation rules for Strict

	if len(errors) > 0 {
		return DeleteFileAndReconcileRequestMultiError(errors)
	}

	return nil
}

// DeleteFileAndReconcileRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteFileAndReconcileRequest.ValidateAll()
// if the designated constraints aren't met.
type DeleteFileAndReconcileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileAndReconcileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileAndReconcileRequestMultiError) AllErrors() []error { return m }

// DeleteFileAndReconcileRequestValidationError is the validation error
// returned by DeleteFileAndReconcileRequest.Validate if the designated
// constraints aren't met.
type DeleteFileAndReconcileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileAndReconcileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileAndReconcileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileAndReconcileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileAndReconcileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileAndReconcileRequestValidationError) ErrorName() string {
	return "DeleteFileAndReconcileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileAndReconcileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileAndReconcileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileAndReconcileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileAndReconcileRequestValidationError{}

var _DeleteFileAndReconcileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on DeleteFileAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteFileAndReconcileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFileAndReconcileResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeleteFileAndReconcileResponseMultiError, or nil if none found.
func (m *DeleteFileAndReconcileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFileAndReconcileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteFileAndReconcileResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteFileAndReconcileResponseMultiError(errors)
	}

	return nil
}

// DeleteFileAndReconcileResponseMultiError is an error wrapping multiple
// validation errors returned by DeleteFileAndReconcileResponse.ValidateAll()
// if the designated constraints aren't met.
type DeleteFileAndReconcileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileAndReconcileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileAndReconcileResponseMultiError) AllErrors() []error { return m }

// DeleteFileAndReconcileResponseValidationError is the validation error
// returned by DeleteFileAndReconcileResponse.Validate if the designated
// constraints aren't met.
type DeleteFileAndReconcileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileAndReconcileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileAndReconcileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileAndReconcileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileAndReconcileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileAndReconcileResponseValidationError) ErrorName() string {
	return "DeleteFileAndReconcileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFileAndReconcileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFileAndReconcileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileAndReconcileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileAndReconcileResponseValidationError{}

// Validate checks the field values on RenameFileAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenameFileAndReconcileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileAndReconcileRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RenameFileAndReconcileRequestMultiError, or nil if none found.
func (m *RenameFileAndReconcileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileAndReconcileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RenameFileAndReconcileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := RenameFileAndReconcileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FromPath

	// no validation rules for ToPath

	// no validation rules for Dry

	// no validation rules for Strict

	if len(errors) > 0 {
		return RenameFileAndReconcileRequestMultiError(errors)
	}

	return nil
}

// RenameFileAndReconcileRequestMultiError is an error wrapping multiple
// validation errors returned by RenameFileAndReconcileRequest.ValidateAll()
// if the designated constraints aren't met.
type RenameFileAndReconcileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileAndReconcileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileAndReconcileRequestMultiError) AllErrors() []error { return m }

// RenameFileAndReconcileRequestValidationError is the validation error
// returned by RenameFileAndReconcileRequest.Validate if the designated
// constraints aren't met.
type RenameFileAndReconcileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileAndReconcileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileAndReconcileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileAndReconcileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileAndReconcileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileAndReconcileRequestValidationError) ErrorName() string {
	return "RenameFileAndReconcileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileAndReconcileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileAndReconcileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileAndReconcileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileAndReconcileRequestValidationError{}

var _RenameFileAndReconcileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on RenameFileAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenameFileAndReconcileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenameFileAndReconcileResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// RenameFileAndReconcileResponseMultiError, or nil if none found.
func (m *RenameFileAndReconcileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenameFileAndReconcileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RenameFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RenameFileAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RenameFileAndReconcileResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RenameFileAndReconcileResponseMultiError(errors)
	}

	return nil
}

// RenameFileAndReconcileResponseMultiError is an error wrapping multiple
// validation errors returned by RenameFileAndReconcileResponse.ValidateAll()
// if the designated constraints aren't met.
type RenameFileAndReconcileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenameFileAndReconcileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenameFileAndReconcileResponseMultiError) AllErrors() []error { return m }

// RenameFileAndReconcileResponseValidationError is the validation error
// returned by RenameFileAndReconcileResponse.Validate if the designated
// constraints aren't met.
type RenameFileAndReconcileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenameFileAndReconcileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenameFileAndReconcileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenameFileAndReconcileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenameFileAndReconcileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenameFileAndReconcileResponseValidationError) ErrorName() string {
	return "RenameFileAndReconcileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenameFileAndReconcileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenameFileAndReconcileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenameFileAndReconcileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenameFileAndReconcileResponseValidationError{}

// Validate checks the field values on RefreshAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshAndReconcileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshAndReconcileRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshAndReconcileRequestMultiError, or nil if none found.
func (m *RefreshAndReconcileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshAndReconcileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RefreshAndReconcileRequest_InstanceId_Pattern.MatchString(m.GetInstanceId()) {
		err := RefreshAndReconcileRequestValidationError{
			field:  "InstanceId",
			reason: "value does not match regex pattern \"^[_\\\\-a-zA-Z0-9]+$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Path

	// no validation rules for Dry

	// no validation rules for Strict

	if len(errors) > 0 {
		return RefreshAndReconcileRequestMultiError(errors)
	}

	return nil
}

// RefreshAndReconcileRequestMultiError is an error wrapping multiple
// validation errors returned by RefreshAndReconcileRequest.ValidateAll() if
// the designated constraints aren't met.
type RefreshAndReconcileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshAndReconcileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshAndReconcileRequestMultiError) AllErrors() []error { return m }

// RefreshAndReconcileRequestValidationError is the validation error returned
// by RefreshAndReconcileRequest.Validate if the designated constraints aren't met.
type RefreshAndReconcileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshAndReconcileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshAndReconcileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshAndReconcileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshAndReconcileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshAndReconcileRequestValidationError) ErrorName() string {
	return "RefreshAndReconcileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshAndReconcileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshAndReconcileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshAndReconcileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshAndReconcileRequestValidationError{}

var _RefreshAndReconcileRequest_InstanceId_Pattern = regexp.MustCompile("^[_\\-a-zA-Z0-9]+$")

// Validate checks the field values on RefreshAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshAndReconcileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshAndReconcileResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshAndReconcileResponseMultiError, or nil if none found.
func (m *RefreshAndReconcileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshAndReconcileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshAndReconcileResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshAndReconcileResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshAndReconcileResponseMultiError(errors)
	}

	return nil
}

// RefreshAndReconcileResponseMultiError is an error wrapping multiple
// validation errors returned by RefreshAndReconcileResponse.ValidateAll() if
// the designated constraints aren't met.
type RefreshAndReconcileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshAndReconcileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshAndReconcileResponseMultiError) AllErrors() []error { return m }

// RefreshAndReconcileResponseValidationError is the validation error returned
// by RefreshAndReconcileResponse.Validate if the designated constraints
// aren't met.
type RefreshAndReconcileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshAndReconcileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshAndReconcileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshAndReconcileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshAndReconcileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshAndReconcileResponseValidationError) ErrorName() string {
	return "RefreshAndReconcileResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshAndReconcileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshAndReconcileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshAndReconcileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshAndReconcileResponseValidationError{}

// Validate checks the field values on Connector with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connector with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectorMultiError, or nil
// if none found.
func (m *Connector) ValidateAll() error {
	return m.validate(true)
}

func (m *Connector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DisplayName

	// no validation rules for Description

	for idx, item := range m.GetProperties() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectorValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectorValidationError{
						field:  fmt.Sprintf("Properties[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectorValidationError{
					field:  fmt.Sprintf("Properties[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConnectorMultiError(errors)
	}

	return nil
}

// ConnectorMultiError is an error wrapping multiple validation errors returned
// by Connector.ValidateAll() if the designated constraints aren't met.
type ConnectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectorMultiError) AllErrors() []error { return m }

// ConnectorValidationError is the validation error returned by
// Connector.Validate if the designated constraints aren't met.
type ConnectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectorValidationError) ErrorName() string { return "ConnectorValidationError" }

// Error satisfies the builtin error interface
func (e ConnectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectorValidationError{}

// Validate checks the field values on ListConnectorsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConnectorsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConnectorsRequestMultiError, or nil if none found.
func (m *ListConnectorsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListConnectorsRequestMultiError(errors)
	}

	return nil
}

// ListConnectorsRequestMultiError is an error wrapping multiple validation
// errors returned by ListConnectorsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListConnectorsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorsRequestMultiError) AllErrors() []error { return m }

// ListConnectorsRequestValidationError is the validation error returned by
// ListConnectorsRequest.Validate if the designated constraints aren't met.
type ListConnectorsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorsRequestValidationError) ErrorName() string {
	return "ListConnectorsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorsRequestValidationError{}

// Validate checks the field values on ListConnectorsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConnectorsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConnectorsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConnectorsResponseMultiError, or nil if none found.
func (m *ListConnectorsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConnectorsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnectors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListConnectorsResponseValidationError{
						field:  fmt.Sprintf("Connectors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListConnectorsResponseValidationError{
					field:  fmt.Sprintf("Connectors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListConnectorsResponseMultiError(errors)
	}

	return nil
}

// ListConnectorsResponseMultiError is an error wrapping multiple validation
// errors returned by ListConnectorsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListConnectorsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConnectorsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConnectorsResponseMultiError) AllErrors() []error { return m }

// ListConnectorsResponseValidationError is the validation error returned by
// ListConnectorsResponse.Validate if the designated constraints aren't met.
type ListConnectorsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConnectorsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConnectorsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConnectorsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConnectorsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConnectorsResponseValidationError) ErrorName() string {
	return "ListConnectorsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConnectorsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConnectorsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConnectorsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConnectorsResponseValidationError{}

// Validate checks the field values on ReconcileError_CharLocation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReconcileError_CharLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReconcileError_CharLocation with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReconcileError_CharLocationMultiError, or nil if none found.
func (m *ReconcileError_CharLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *ReconcileError_CharLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Line

	// no validation rules for Column

	if len(errors) > 0 {
		return ReconcileError_CharLocationMultiError(errors)
	}

	return nil
}

// ReconcileError_CharLocationMultiError is an error wrapping multiple
// validation errors returned by ReconcileError_CharLocation.ValidateAll() if
// the designated constraints aren't met.
type ReconcileError_CharLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReconcileError_CharLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReconcileError_CharLocationMultiError) AllErrors() []error { return m }

// ReconcileError_CharLocationValidationError is the validation error returned
// by ReconcileError_CharLocation.Validate if the designated constraints
// aren't met.
type ReconcileError_CharLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReconcileError_CharLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReconcileError_CharLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReconcileError_CharLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReconcileError_CharLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReconcileError_CharLocationValidationError) ErrorName() string {
	return "ReconcileError_CharLocationValidationError"
}

// Error satisfies the builtin error interface
func (e ReconcileError_CharLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReconcileError_CharLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReconcileError_CharLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReconcileError_CharLocationValidationError{}

// Validate checks the field values on Connector_Property with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Connector_Property) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connector_Property with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Connector_PropertyMultiError, or nil if none found.
func (m *Connector_Property) ValidateAll() error {
	return m.validate(true)
}

func (m *Connector_Property) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for DisplayName

	// no validation rules for Description

	// no validation rules for Placeholder

	if _, ok := Connector_Property_Type_name[int32(m.GetType())]; !ok {
		err := Connector_PropertyValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Nullable

	// no validation rules for Hint

	// no validation rules for Href

	if len(errors) > 0 {
		return Connector_PropertyMultiError(errors)
	}

	return nil
}

// Connector_PropertyMultiError is an error wrapping multiple validation errors
// returned by Connector_Property.ValidateAll() if the designated constraints
// aren't met.
type Connector_PropertyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Connector_PropertyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Connector_PropertyMultiError) AllErrors() []error { return m }

// Connector_PropertyValidationError is the validation error returned by
// Connector_Property.Validate if the designated constraints aren't met.
type Connector_PropertyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Connector_PropertyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Connector_PropertyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Connector_PropertyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Connector_PropertyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Connector_PropertyValidationError) ErrorName() string {
	return "Connector_PropertyValidationError"
}

// Error satisfies the builtin error interface
func (e Connector_PropertyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnector_Property.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Connector_PropertyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Connector_PropertyValidationError{}
